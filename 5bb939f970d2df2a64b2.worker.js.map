{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/buffer/node_modules/isarray/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/moneypot-lib/dist/abstract-transfer.js","webpack:///./node_modules/moneypot-lib/dist/acknowledged.js","webpack:///./node_modules/moneypot-lib/dist/blind.js","webpack:///./node_modules/moneypot-lib/dist/blinded-message.js","webpack:///./node_modules/moneypot-lib/dist/blinded-signature.js","webpack:///./node_modules/moneypot-lib/dist/bolt11.js","webpack:///./node_modules/moneypot-lib/dist/claim-request.js","webpack:///./node_modules/moneypot-lib/dist/claimable.js","webpack:///./node_modules/moneypot-lib/dist/coin.js","webpack:///./node_modules/moneypot-lib/dist/custodian-info.js","webpack:///./node_modules/moneypot-lib/dist/fee-bump.js","webpack:///./node_modules/moneypot-lib/dist/hash.js","webpack:///./node_modules/moneypot-lib/dist/hookin.js","webpack:///./node_modules/moneypot-lib/dist/hookout.js","webpack:///./node_modules/moneypot-lib/dist/index.js","webpack:///./node_modules/moneypot-lib/dist/lightning-invoice.js","webpack:///./node_modules/moneypot-lib/dist/lightning-payment.js","webpack:///./node_modules/moneypot-lib/dist/magnitude.js","webpack:///./node_modules/moneypot-lib/dist/pod.js","webpack:///./node_modules/moneypot-lib/dist/private-key.js","webpack:///./node_modules/moneypot-lib/dist/public-key.js","webpack:///./node_modules/moneypot-lib/dist/signature.js","webpack:///./node_modules/moneypot-lib/dist/status/abstract-status.js","webpack:///./node_modules/moneypot-lib/dist/status/bitcoin-transaction-sent.js","webpack:///./node_modules/moneypot-lib/dist/status/claimed.js","webpack:///./node_modules/moneypot-lib/dist/status/compute-claimable-remaining.js","webpack:///./node_modules/moneypot-lib/dist/status/failed.js","webpack:///./node_modules/moneypot-lib/dist/status/hookin-accepted.js","webpack:///./node_modules/moneypot-lib/dist/status/index.js","webpack:///./node_modules/moneypot-lib/dist/status/invoice-settled.js","webpack:///./node_modules/moneypot-lib/dist/status/lightning-payment-sent.js","webpack:///./node_modules/moneypot-lib/dist/util/assert.js","webpack:///./node_modules/moneypot-lib/dist/util/base58.js","webpack:///./node_modules/moneypot-lib/dist/util/bcrypto/hmac.js","webpack:///./node_modules/moneypot-lib/dist/util/bcrypto/ripemd160.js","webpack:///./node_modules/moneypot-lib/dist/util/bcrypto/sha256.js","webpack:///./node_modules/moneypot-lib/dist/util/bcrypto/sha512.js","webpack:///./node_modules/moneypot-lib/dist/util/bech32.js","webpack:///./node_modules/moneypot-lib/dist/util/bitcoin-address.js","webpack:///./node_modules/moneypot-lib/dist/util/bs58check.js","webpack:///./node_modules/moneypot-lib/dist/util/buffutils.js","webpack:///./node_modules/moneypot-lib/dist/util/coins.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/blind.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/check.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/elliptic.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/index.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/mu-sig.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/signature.js","webpack:///./node_modules/moneypot-lib/dist/util/ecc/util.js","webpack:///./node_modules/moneypot-lib/dist/util/random-browser.js","webpack:///./node_modules/moneypot-lib/dist/util/types.js","webpack:///./node_modules/moneypot-lib/dist/util/wif.js","webpack:///./src/wallet/workers/WorkerCoins.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/wallet/requests/get-claimable-by-input-owner.ts","webpack:///./src/wallet/requests/make-request.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,oDAAW;AAChC,cAAc,mBAAO,CAAC,gDAAS;AAC/B,cAAc,mBAAO,CAAC,oEAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5vDA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;;;;;;;ACnFa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,sEAAe;AACxC,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,YAAY,mBAAO,CAAC,sDAAO;AAC3B,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACzHa;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,kBAAkB,mBAAO,CAAC,8DAAW;AACrC,mBAAmB,mBAAO,CAAC,gEAAY;AACvC,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD,iBAAiB,mBAAO,CAAC,4DAAU;AACnC,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,iBAAiB,mBAAO,CAAC,kEAAU;AACnC,0BAA0B,mBAAO,CAAC,4FAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;AC9Fa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,8EAAmB;AACrD,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,YAAY,mBAAO,CAAC,sEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACrBa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,sEAAe;AACtC,YAAY,mBAAO,CAAC,4EAAkB;AACtC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;AClCa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,sEAAe;AACtC,YAAY,mBAAO,CAAC,sEAAY;AAChC,eAAe,mBAAO,CAAC,sEAAe;AACtC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACpCA,8CAAa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,eAAe,mBAAO,CAAC,sEAAe;AACtC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,0BAA0B,mBAAO,CAAC,wFAAwB;AAC1D,iBAAiB,mBAAO,CAAC,sFAAuB;AAChD,YAAY,mBAAO,CAAC,sEAAY;AAChC,oBAAoB,mBAAO,CAAC,oFAAsB;AAClD,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qEAAqE;AACrE,wFAAwF;AACxF,qGAAqG;AACrG,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS,sCAAsC,oDAAoD;AAClH;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS,sCAAsC,wDAAwD;AACtH;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;ACzxBa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,8EAAmB;AACrD,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,oBAAoB,mBAAO,CAAC,kEAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACtFa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,8DAAW;AACrC,mBAAmB,mBAAO,CAAC,gEAAY;AACvC,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD,iBAAiB,mBAAO,CAAC,4DAAU;AACnC;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC3Ea;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,oBAAoB,mBAAO,CAAC,kEAAa;AACzC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACnDa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,eAAe,mBAAO,CAAC,sEAAe;AACtC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AC/Da;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,eAAe,mBAAO,CAAC,sEAAe;AACtC,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,sEAAe;AACtC,eAAe,mBAAO,CAAC,sEAAe;AACtC,iBAAiB,mBAAO,CAAC,sFAAuB;AAChD,iBAAiB,mBAAO,CAAC,4EAAkB;AAC3C,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;AC9Ca;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,sBAAsB,mBAAO,CAAC,sEAAe;AAC7C,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,YAAY,mBAAO,CAAC,sDAAO;AAC3B,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AChFa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACnDa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA,YAAY,mBAAO,CAAC,sDAAO;AAC3B;AACA;AACA,wBAAwB,mBAAO,CAAC,8EAAmB;AACnD;AACA,0BAA0B,mBAAO,CAAC,kFAAqB;AACvD;AACA,aAAa,mBAAO,CAAC,wDAAQ;AAC7B;AACA,oBAAoB,mBAAO,CAAC,sEAAe;AAC3C;AACA,mBAAmB,mBAAO,CAAC,oEAAc;AACzC;AACA,kBAAkB,mBAAO,CAAC,kEAAa;AACvC;AACA;AACA,aAAa,mBAAO,CAAC,wDAAQ;AAC7B;AACA,yBAAyB,mBAAO,CAAC,4EAAkB;AACnD;AACA,eAAe,mBAAO,CAAC,4DAAU;AACjC;AACA,kBAAkB,mBAAO,CAAC,8DAAW;AACrC;AACA,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD;AACA,mBAAmB,mBAAO,CAAC,gEAAY;AACvC;AACA,kBAAkB,mBAAO,CAAC,kEAAa;AACvC;AACA,0BAA0B,mBAAO,CAAC,kFAAqB;AACvD;AACA,SAAS,mBAAO,CAAC,kEAAa;AAC9B,SAAS,mBAAO,CAAC,kEAAU;AAC3B,oCAAoC,mBAAO,CAAC,oHAAsC;AAClF;AACA;AACA,SAAS,mBAAO,CAAC,0DAAS;AAC1B;AACA,SAAS,mBAAO,CAAC,oEAAc;AAC/B,SAAS,mBAAO,CAAC,4DAAU;AAC3B,SAAS,mBAAO,CAAC,wFAAwB;AACzC,sBAAsB,mBAAO,CAAC,0EAAiB;AAC/C;AACA,qBAAqB,mBAAO,CAAC,wEAAgB;AAC7C;AACA,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD;AACA;AACA,eAAe,mBAAO,CAAC,8EAAe;AACtC;AACA,eAAe,mBAAO,CAAC,sFAAuB;AAC9C;AACA,eAAe,mBAAO,CAAC,sFAAuB;AAC9C;AACA,kBAAkB,mBAAO,CAAC,4FAA0B;AACpD;AACA,iC;;;;;;;;;;;;AChEa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACjDa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,eAAe,mBAAO,CAAC,4DAAU;AACjC,4BAA4B,mBAAO,CAAC,kFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC/Ca;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC3Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,YAAY,mBAAO,CAAC,sEAAY;AAChC,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,qBAAqB,mBAAO,CAAC,oEAAc;AAC3C,eAAe,mBAAO,CAAC,sEAAe;AACtC,YAAY,mBAAO,CAAC,gEAAY;AAChC,iBAAiB,mBAAO,CAAC,8EAAe;AACxC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,iBAAiB,mBAAO,CAAC,8EAAmB;AAC5C,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACtFa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,wDAAQ;AAC/B,YAAY,mBAAO,CAAC,kFAAqB;AACzC,eAAe,mBAAO,CAAC,sEAAe;AACtC,oBAAoB,mBAAO,CAAC,4FAA0B;AACtD,iBAAiB,mBAAO,CAAC,sFAAuB;AAChD,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,WAAW,mBAAO,CAAC,oDAAG;AACtB,iBAAiB,mBAAO,CAAC,8EAAmB;AAC5C,iBAAiB,mBAAO,CAAC,sEAAe;AACxC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC3Ga;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,sEAAe;AACtC,eAAe,mBAAO,CAAC,sEAAe;AACtC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,YAAY,mBAAO,CAAC,sEAAY;AAChC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACrDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,eAAe,mBAAO,CAAC,yDAAS;AAChC,kBAAkB,mBAAO,CAAC,6EAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;ACpCa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,4BAA4B,mBAAO,CAAC,mFAAsB;AAC1D,wBAAwB,mBAAO,CAAC,2EAAkB;AAClD,eAAe,mBAAO,CAAC,yDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACvDa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,mEAAU;AACnC,kBAAkB,mBAAO,CAAC,qEAAW;AACrC,iCAAiC,mBAAO,CAAC,mGAA0B;AACnE,mCAAmC,mBAAO,CAAC,uGAA4B;AACvE,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,iBAAiB,mBAAO,CAAC,6DAAW;AACpC,4BAA4B,mBAAO,CAAC,mFAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACpDa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,eAAe,mBAAO,CAAC,yDAAS;AAChC,kBAAkB,mBAAO,CAAC,6EAAmB;AAC7C,YAAY,mBAAO,CAAC,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,eAAe,mBAAO,CAAC,yDAAS;AAChC,YAAY,mBAAO,CAAC,uDAAQ;AAC5B,kBAAkB,mBAAO,CAAC,6EAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qEAAW;AACrC,iBAAiB,mBAAO,CAAC,mEAAU;AACnC,mCAAmC,mBAAO,CAAC,uGAA4B;AACvE,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,iCAAiC,mBAAO,CAAC,mGAA0B;AACnE,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACrEa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,eAAe,mBAAO,CAAC,yDAAS;AAChC,kBAAkB,mBAAO,CAAC,6EAAmB;AAC7C,YAAY,mBAAO,CAAC,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACtDa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,qFAAmB;AACrD,eAAe,mBAAO,CAAC,yDAAS;AAChC,kBAAkB,mBAAO,CAAC,6EAAmB;AAC7C,YAAY,mBAAO,CAAC,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC7Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACrIa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,kEAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;AC7CA,8CAAa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,kEAAW;AACpC,kBAAkB,mBAAO,CAAC,wEAAc;AACxC,eAAe,mBAAO,CAAC,qEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;ACzgBa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,kEAAW;AACpC,eAAe,mBAAO,CAAC,qEAAQ;AAC/B,kBAAkB,mBAAO,CAAC,wEAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjPa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,kEAAW;AACpC,kBAAkB,mBAAO,CAAC,wEAAc;AACxC,eAAe,mBAAO,CAAC,qEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACvhBa;AACb;AACA,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,iEAAU;AACjC;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACxJa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,uEAAa;AACvC,eAAe,mBAAO,CAAC,iEAAU;AACjC,kBAAkB,mBAAO,CAAC,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACrFa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,iFAAkB;AAC3C,eAAe,mBAAO,CAAC,iEAAU;AACjC,kBAAkB,mBAAO,CAAC,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,iEAAU;AACjC,cAAc,mBAAO,CAAC,+DAAS;AAC/B;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACvLa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,iEAAU;AACjC,oBAAoB,mBAAO,CAAC,mEAAc;AAC1C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC3Ba;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,yEAAY;AACvC,iBAAiB,mBAAO,CAAC,kFAAmB;AAC5C,eAAe,mBAAO,CAAC,iEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB,GAAG,IAAI;AACzC;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA,YAAY;AACZ;AACA;AACA,iC;;;;;;;;;;;;AC1Ca;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,6DAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC9Ea;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,mEAAS;AAC/B,eAAe,mBAAO,CAAC,iEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AClOa;AACb;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,yEAAY;AACrC;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,yEAAY;AACrC;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,2EAAa;AACvC;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,mEAAS;AAC/B;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,qEAAU;AAChC;AACA;AACA,aAAa,mBAAO,CAAC,iEAAQ;AAC7B;AACA,iC;;;;;;;;;;;;AC5Ba;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,kEAAW;AAClC,WAAW,mBAAO,CAAC,6DAAG;AACtB,cAAc,mBAAO,CAAC,mEAAS;AAC/B,iBAAiB,mBAAO,CAAC,kFAAmB;AAC5C,eAAe,mBAAO,CAAC,iEAAQ;AAC/B,mBAAmB,mBAAO,CAAC,yEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACtEa;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,mEAAS;AAC/B,mBAAmB,mBAAO,CAAC,yEAAY;AACvC,eAAe,mBAAO,CAAC,iEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa,OAAO;AACpB;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mEAAmE;AACnE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC7Ia;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,kEAAW;AACpC,iBAAiB,mBAAO,CAAC,kFAAmB;AAC5C,gBAAgB,mBAAO,CAAC,mEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACvOa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACtCa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;AChDA;AAAA;AAAgF;AAGhF,cAAc;AACd,MAAM,GAAG,GAAW,IAAW,CAAC;AAEhC,GAAG,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,OAAqB,EAAE,EAAE,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAE1G,KAAK,UAAU,WAAW,CAAC,KAAkB,EAAE,MAAc;IAC3D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,SAAS,GAAG,MAAM,sFAAwB,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACrE,IAAI,CAAC,SAAS,EAAE;YACd,SAAS;SACV;QACD,GAAG,CAAC,WAAW,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;KAClD;IACD,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;AACvB,CAAC;;;;;;;;;;;;AClBD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAmC;AAEwB;AAE5C,KAAK,UAAU,wBAAwB,CAAC,MAAc,EAAE,aAAqB;IAC1F,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,YAAY,6BAA6B,aAAa,EAAE,CAAC;IAE/E,MAAM,YAAY,GAAG,MAAM,6DAAW,CAAkD,GAAG,CAAC,CAAC;IAE7F,IAAI,YAAY,YAAY,0DAAY,EAAE;QACxC,MAAM,YAAY,CAAC;KACpB;IACD,IAAI,CAAC,YAAY,EAAE;QACjB,OAAO,SAAS,CAAC;KAClB;IAED,MAAM,aAAa,GAAG,yDAAe,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;IACrE,IAAI,aAAa,YAAY,KAAK,EAAE;QAClC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;QAC7B,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;KAC9C;IAED,MAAM,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAC;IAEzC,IAAI,CAAC,CAAC,SAAS,YAAY,6DAAmB,CAAC,EAAE;QAC/C,MAAM,IAAI,KAAK,CAAC,4EAA4E,CAAC,CAAC;KAC/F;IAED,IAAI,KAAK,GAAG,KAAK,CAAC;IAClB,KAAK,MAAM,KAAK,IAAI,SAAS,CAAC,MAAM,EAAE;QACpC,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,aAAa,EAAE;YACzC,KAAK,GAAG,IAAI,CAAC;YACb,MAAM;SACP;KACF;IAED,IAAI,CAAC,KAAK,EAAE;QACV,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;KACxE;IAED,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,kBAAkB,CAAC,EAAE;QAC9D,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,EAAC,aAAa;KACzE;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;;;;;;;;;;;;;AC5CD;AAAA;AAAA;AAAO,MAAM,YAAY;IAIvB,YAAY,OAAY,EAAE,UAAkB;QAC1C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;CACF;AAED,wBAAwB;AACT,KAAK,UAAU,WAAW,CAAI,GAAW,EAAE,IAAU;IAClE,IAAI,WAAW,CAAC;IAEhB,IAAI;QACF,WAAW,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE;YAC7B,MAAM,EAAE,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM;YAC3C,IAAI,EAAE,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;SAC5D,CAAC,CAAC;KACJ;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;KACjC;IAED,IAAI,IAAI,GAAG,MAAM,WAAW,CAAC,IAAI,EAAE,CAAC;IAEpC,IAAI,WAAW,CAAC,MAAM,KAAK,GAAG,EAAE;QAC9B,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;QACpC,OAAO,IAAI,YAAY,CAAC,IAAI,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;KACnD;IAED,OAAO,IAAS,CAAC;AACnB,CAAC","file":"5bb939f970d2df2a64b2.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://wallet.moneypot.com/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/ts-loader/index.js!./src/wallet/workers/WorkerCoins.ts\");\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"./util/assert\");\nconst hash_1 = require(\"./hash\");\nconst signature_1 = require(\"./signature\");\nconst POD = require(\"./pod\");\nconst coin_1 = require(\"./coin\");\nconst public_key_1 = require(\"./public-key\");\nconst buffutils = require(\"./util/buffutils\");\nclass AbstractTransfer {\n    constructor({ amount, authorization, fee, inputs }) {\n        this.amount = amount;\n        this.authorization = authorization;\n        this.fee = fee;\n        assert_1.default(isHashSorted(inputs));\n        this.inputs = inputs;\n    }\n    static sort(hashable) {\n        hashable.sort((a, b) => buffutils.compare(a.hash().buffer, b.hash().buffer));\n    }\n    static sortHashes(hashes) {\n        hashes.sort((a, b) => buffutils.compare(a.buffer, b.buffer));\n    }\n    static transferHash(td) {\n        return hash_1.default.fromMessage('Transfer', buffutils.fromUint64(td.amount), buffutils.fromUint64(td.fee), buffutils.fromUint64(td.inputs.length), ...td.inputs.map(i => i.buffer));\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            amount: this.amount,\n            authorization: this.authorization ? this.authorization.toPOD() : null,\n            claimant: this.claimant.toPOD(),\n            fee: this.fee,\n            inputs: this.inputs.map(i => i.toPOD()),\n        };\n    }\n    get claimableAmount() {\n        return this.inputAmount() - this.amount - this.fee;\n    }\n    inputAmount() {\n        let amount = 0;\n        for (const coin of this.inputs) {\n            amount += coin.amount;\n        }\n        return amount;\n    }\n    get claimant() {\n        return public_key_1.default.combine(this.inputs.map(coin => coin.owner));\n    }\n    isAuthorized() {\n        if (!this.authorization) {\n            return false;\n        }\n        const msg = hash_1.default.fromMessage('authorization', this.hash().buffer).buffer;\n        return this.authorization.verify(msg, this.claimant);\n    }\n    authorize(combinedInputPrivkey) {\n        this.authorization = signature_1.default.compute(hash_1.default.fromMessage('authorization', this.hash().buffer).buffer, combinedInputPrivkey);\n    }\n}\nexports.default = AbstractTransfer;\nfunction parseTransferData(data) {\n    if (typeof data !== 'object') {\n        return new Error('expected an object to deserialize a Transfer');\n    }\n    const amount = data.amount;\n    if (!POD.isAmount(amount)) {\n        return new Error('Transfer.fromPOD invalid amount');\n    }\n    const authorization = data.authorization !== null ? signature_1.default.fromPOD(data.authorization) : undefined;\n    if (authorization instanceof Error) {\n        return authorization;\n    }\n    const fee = data.fee;\n    if (!POD.isAmount(fee)) {\n        return new Error('Transfer.fromPOD invalid fee');\n    }\n    let inputAmount = 0;\n    const inputs = [];\n    for (const i of data.inputs) {\n        const input = coin_1.default.fromPOD(i);\n        if (input instanceof Error) {\n            return input;\n        }\n        inputAmount += input.amount;\n        inputs.push(input);\n    }\n    if (!isHashSorted(inputs)) {\n        return new Error('inputs are not in sorted order');\n    }\n    if (inputAmount < amount + fee) {\n        return new Error('not sourcing enough input for amount and fee');\n    }\n    return { amount, authorization, fee, inputs };\n}\nexports.parseTransferData = parseTransferData;\nfunction isHashSorted(ts) {\n    for (let i = 1; i < ts.length; i++) {\n        const c = buffutils.compare(ts[i - 1].hash().buffer, ts[i].hash().buffer);\n        if (c > 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSorted(ts) {\n    for (let i = 1; i < ts.length; i++) {\n        const c = buffutils.compare(ts[i - 1].buffer, ts[i].buffer);\n        if (c > 0) {\n            return false;\n        }\n    }\n    return true;\n}\n// TODO: these sort can be optimized to check if it's already sorted, if so, just return original\nfunction hashSort(ts) {\n    return [...ts].sort((a, b) => buffutils.compare(a.hash().buffer, b.hash().buffer));\n}\nfunction sort(ts) {\n    return [...ts].sort((a, b) => buffutils.compare(a.buffer, b.buffer));\n}\n//# sourceMappingURL=abstract-transfer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst signature_1 = require(\"./signature\");\nconst hookout_1 = require(\"./hookout\");\nconst fee_bump_1 = require(\"./fee-bump\");\nconst lightning_payment_1 = require(\"./lightning-payment\");\nconst lightning_invoice_1 = require(\"./lightning-invoice\");\nconst hookin_1 = require(\"./hookin\");\nconst claimable_1 = require(\"./claimable\");\nconst status_1 = require(\"./status\");\nconst abstract_status_1 = require(\"./status/abstract-status\");\n// T is what is acknowledged, a P is the type of a  T.toPOD()\n// type inference of this thing kind of sucks. So it's recommended to use\n// x: AcknowledgedX = hi.Acknowledged(....)  to guide it\nclass Acknowledged {\n    // Warning: The constructor does not validate the signature\n    constructor(contents, acknowledgement, toPOD) {\n        this.acknowledgement = acknowledgement;\n        this.contents = contents;\n        this.toPOD = () => ({\n            acknowledgement: this.acknowledgement.toPOD(),\n            ...toPOD(this.contents),\n        });\n    }\n    static acknowledge(contents, acknowledgeKey, toPOD) {\n        const hash = contents.hash();\n        const acknowledgement = signature_1.default.compute(hash.buffer, acknowledgeKey);\n        return new Acknowledged(contents, acknowledgement, toPOD);\n    }\n    // Need to check .verify()\n    static fromPOD(creator, toPOD, data) {\n        const contents = creator(data);\n        if (contents instanceof Error) {\n            throw contents;\n        }\n        const acknowledgement = signature_1.default.fromPOD(data.acknowledgement);\n        if (acknowledgement instanceof Error) {\n            return acknowledgement;\n        }\n        return new Acknowledged(contents, acknowledgement, toPOD);\n    }\n    verify(acknowledgementPublicKey) {\n        const hash = this.contents.hash();\n        return this.acknowledgement.verify(hash.buffer, acknowledgementPublicKey);\n    }\n    hash() {\n        return this.contents.hash();\n    }\n}\nexports.default = Acknowledged;\nfunction hookinFromPod(x) {\n    return Acknowledged.fromPOD(hookin_1.default.fromPOD, (d) => d.toPOD(), x);\n}\nexports.hookinFromPod = hookinFromPod;\nfunction feeBumpFromPod(x) {\n    return Acknowledged.fromPOD(fee_bump_1.default.fromPOD, (d) => d.toPOD(), x);\n}\nexports.feeBumpFromPod = feeBumpFromPod;\nfunction lightningPaymentFromPod(x) {\n    return Acknowledged.fromPOD(lightning_payment_1.default.fromPOD, (d) => d.toPOD(), x);\n}\nexports.lightningPaymentFromPod = lightningPaymentFromPod;\nfunction lightningInvoiceFromPod(x) {\n    return Acknowledged.fromPOD(lightning_invoice_1.default.fromPOD, (d) => d.toPOD(), x);\n}\nexports.lightningInvoiceFromPod = lightningInvoiceFromPod;\nfunction hookoutFromPod(x) {\n    return Acknowledged.fromPOD(hookout_1.default.fromPOD, (d) => d.toPOD(), x);\n}\nexports.hookoutFromPod = hookoutFromPod;\nfunction claimableFromPOD(x) {\n    return Acknowledged.fromPOD(claimable_1.claimableFromPOD, claimable_1.claimableToPOD, x);\n}\nexports.claimableFromPOD = claimableFromPOD;\nfunction statusFromPOD(x) {\n    return Acknowledged.fromPOD(status_1.statusFromPOD, status_1.statusToPOD, x);\n}\nexports.statusFromPOD = statusFromPOD;\nfunction acknowledge(x, acknowledgeKey) {\n    if (x instanceof hookout_1.default ||\n        x instanceof fee_bump_1.default ||\n        x instanceof lightning_payment_1.default ||\n        x instanceof lightning_invoice_1.default ||\n        x instanceof hookin_1.default) {\n        return Acknowledged.acknowledge(x, acknowledgeKey, claimable_1.claimableToPOD);\n    }\n    else if (x instanceof abstract_status_1.default) {\n        return Acknowledged.acknowledge(x, acknowledgeKey, status_1.statusToPOD);\n    }\n    else {\n        return Acknowledged.acknowledge(x, acknowledgeKey, (z) => z.toPOD());\n    }\n}\nexports.acknowledge = acknowledge;\n//# sourceMappingURL=acknowledged.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst blinded_message_1 = require(\"./blinded-message\");\nconst blinded_signature_1 = require(\"./blinded-signature\");\nconst signature_1 = require(\"./signature\");\nconst ecc = require(\"./util/ecc\");\nfunction blindMessage(secretRandomSeed, nonce, signer, message) {\n    const [unblinder, bm] = ecc.blindMessage(secretRandomSeed, nonce, signer, message);\n    return [unblinder, new blinded_message_1.default(bm.c)];\n}\nexports.blindMessage = blindMessage;\nfunction blindSign(signer, nonce, blindedMessage) {\n    const bs = ecc.blindSign(signer.scalar, nonce.scalar, blindedMessage);\n    return new blinded_signature_1.default(bs.s);\n}\nexports.blindSign = blindSign;\nfunction unblind(unblinder, blindedSig) {\n    const sig = ecc.unblind(unblinder, blindedSig);\n    return new signature_1.default(sig.r, sig.s);\n}\nexports.unblind = unblind;\n//# sourceMappingURL=blind.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bech32 = require(\"./util/bech32\");\nconst ecc = require(\"./util/ecc/index\");\nconst serializedPrefix = 'bmmp'; // blinded message moneypot\nclass BlindedMessage {\n    constructor(challenge) {\n        this.c = challenge;\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'string') {\n            return new Error('BlindedMessage.fromPOD expected a string');\n        }\n        const { prefix, words } = bech32.decode(data);\n        if (prefix !== serializedPrefix) {\n            return new Error('Got prefix: ' + prefix + ' but expected ' + serializedPrefix);\n        }\n        return BlindedMessage.fromBytes(bech32.fromWords(words));\n    }\n    static fromBytes(bytes) {\n        const c = ecc.Scalar.fromBytes(bytes);\n        if (c instanceof Error) {\n            return c;\n        }\n        return new BlindedMessage(c);\n    }\n    get buffer() {\n        return ecc.Scalar.toBytes(this.c);\n    }\n    toPOD() {\n        return bech32.encode(serializedPrefix, bech32.toWords(this.buffer));\n    }\n}\nexports.default = BlindedMessage;\n//# sourceMappingURL=blinded-message.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"./util/assert\");\nconst ecc = require(\"./util/ecc\");\nconst bech32 = require(\"./util/bech32\");\nconst serializedPrefix = 'bsmp'; // blinded signature moneypot\nclass BlindedSignature {\n    constructor(s) {\n        this.s = s;\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'string') {\n            return new Error('BlindedSignature.fromPOD expected a string');\n        }\n        const { prefix, words } = bech32.decode(data);\n        if (prefix !== serializedPrefix) {\n            return new Error('Got prefix: ' + prefix + ' but expected ' + serializedPrefix);\n        }\n        return BlindedSignature.fromBytes(bech32.fromWords(words));\n    }\n    static fromBytes(bytes) {\n        assert.equal(bytes.length, 32);\n        const s = ecc.Scalar.fromBytes(bytes);\n        if (s instanceof Error) {\n            return s;\n        }\n        return new BlindedSignature(s);\n    }\n    get buffer() {\n        return ecc.Scalar.toBytes(this.s);\n    }\n    toPOD() {\n        return bech32.encode(serializedPrefix, bech32.toWords(this.buffer));\n    }\n}\nexports.default = BlindedSignature;\n//# sourceMappingURL=blinded-signature.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst public_key_1 = require(\"./public-key\");\nconst bech32 = require(\"./util/bech32\");\nconst buffutils = require(\"./util/buffutils\");\nconst bitcoin_address_1 = require(\"./util/bitcoin-address\");\nconst sha256_1 = require(\"./util/bcrypto/sha256\");\nconst ecc = require(\"./util/ecc\");\nconst signature_1 = require(\"./util/ecc/signature\");\nconst signature_2 = require(\"./signature\");\nconst bs58check = require(\"./util/bs58check\");\nconst MAX_MILLISATS = BigInt('2100000000000000000');\nconst MILLISATS_PER_BTC = BigInt(1e11);\nconst MILLISATS_PER_MILLIBTC = BigInt(1e8);\nconst MILLISATS_PER_MICROBTC = BigInt(1e5);\nconst MILLISATS_PER_NANOBTC = BigInt(1e2);\nconst PICOBTC_PER_MILLISATS = BigInt(10);\n// const DIVISORS = {\n//   m: BigInt(1e3),\n//   u: BigInt(1e6),\n//   n: BigInt(1e9),\n//   p: BigInt(1e12)\n// }\nfunction DIVISORS(l) {\n    switch (l) {\n        case 'm':\n            return BigInt(1e3);\n        case 'u':\n            return BigInt(1e6);\n        case 'n':\n            return BigInt(1e9);\n        case 'p':\n            return BigInt(1e12);\n        default:\n            throw new Error('unknown denom: ' + l);\n    }\n}\nfunction hrpToMillisat(hrpString) {\n    let divisor, value;\n    if (hrpString.slice(-1).match(/^[munp]$/)) {\n        divisor = hrpString.slice(-1);\n        value = hrpString.slice(0, -1);\n    }\n    else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {\n        throw new Error('Not a valid multiplier for the amount');\n    }\n    else {\n        value = hrpString;\n    }\n    if (!value.match(/^\\d+$/))\n        throw new Error('Not a valid human readable amount');\n    let valueBN = BigInt(value);\n    let millisatoshisBN = divisor ? (valueBN * MILLISATS_PER_BTC) / DIVISORS(divisor) : valueBN * MILLISATS_PER_BTC;\n    if ((divisor === 'p' && valueBN % BigInt(10) != BigInt(0)) || millisatoshisBN > MAX_MILLISATS) {\n        throw new Error('Amount is outside of valid range');\n    }\n    return millisatoshisBN;\n}\nexports.hrpToMillisat = hrpToMillisat;\nfunction hrpToSat(hrpString) {\n    let millisatoshisBN = hrpToMillisat(hrpString);\n    if (millisatoshisBN % BigInt(1000) !== BigInt(0)) {\n        throw new Error('Amount is outside of valid range');\n    }\n    return millisatoshisBN / BigInt(1000);\n}\nexports.hrpToSat = hrpToSat;\nfunction wordsToIntBE(words) {\n    let total = 0;\n    for (const [index, item] of words.reverse().entries()) {\n        total += item * 32 ** index;\n    }\n    return total;\n}\nfunction wordsToBuffer(words, trim) {\n    let buffer = bech32.convert(words, 5, 8, true);\n    if (trim && (words.length * 5) % 8 !== 0) {\n        buffer = buffer.slice(0, -1);\n    }\n    return buffer;\n}\nconst unknownTagName = 'unknownTag';\nconst TAGPARSERS = new Map([\n    [1, (words) => buffutils.toHex(wordsToBuffer(words, true))],\n    [13, (words) => buffutils.toString(wordsToBuffer(words, true))],\n    [19, (words) => buffutils.toHex(wordsToBuffer(words, true))],\n    [23, (words) => buffutils.toHex(wordsToBuffer(words, true))],\n    [6, wordsToIntBE],\n    [24, wordsToIntBE],\n    [9, fallbackAddressParser],\n    [3, routingInfoParser],\n]);\nfunction getUnknownParser(tagCode) {\n    return (words) => ({\n        tagCode,\n        words: bech32.encode('unknown', words),\n    });\n}\n// see encoder for details\nfunction fallbackAddressParser(words, network) {\n    let version = words[0];\n    words = words.slice(1);\n    let addressHash = wordsToBuffer(words, true);\n    let address = null;\n    switch (version) {\n        case 17:\n            address = bitcoin_address_1.toBase58Check(addressHash, network.pubKeyHash);\n            break;\n        case 18:\n            address = bitcoin_address_1.toBase58Check(addressHash, network.scriptHash);\n            break;\n        case 0:\n            address = bitcoin_address_1.toBech32(addressHash, version, network.bech32);\n            break;\n        default:\n            throw new Error('unknown version: ' + version);\n    }\n    return {\n        code: version,\n        address,\n        addressHash: buffutils.toHex(addressHash),\n    };\n}\n// first convert from words to buffer, trimming padding where necessary\n// parse in 51 byte chunks. See encoder for details.\nfunction routingInfoParser(words) {\n    let routes = [];\n    let pubkey, shortChannelId, feeBaseMSats, feeProportionalMillionths, cltvExpiryDelta;\n    let routesBuffer = wordsToBuffer(words, true);\n    while (routesBuffer.length > 0) {\n        pubkey = buffutils.toHex(routesBuffer.slice(0, 33)); // 33 bytes\n        shortChannelId = buffutils.toHex(routesBuffer.slice(33, 41)); // 8 bytes\n        feeBaseMSats = Number.parseInt(buffutils.toHex(routesBuffer.slice(41, 45)), 16); // 4 bytes\n        feeProportionalMillionths = Number.parseInt(buffutils.toHex(routesBuffer.slice(45, 49)), 16); // 4 bytes\n        cltvExpiryDelta = Number.parseInt(buffutils.toHex(routesBuffer.slice(49, 51)), 16); // 2 bytes\n        routesBuffer = routesBuffer.slice(51);\n        routes.push({\n            pubkey,\n            short_channel_id: shortChannelId,\n            fee_base_msat: feeBaseMSats,\n            fee_proportional_millionths: feeProportionalMillionths,\n            cltv_expiry_delta: cltvExpiryDelta,\n        });\n    }\n    return routes;\n}\nconst BECH32CODES = {\n    bc: 'bitcoin',\n    tb: 'testnet',\n    bcrt: 'regtest',\n    ltc: 'litecoin',\n    tltc: 'litecoin_testnet',\n};\nconst TAGCODES = {\n    payment_hash: 1,\n    description: 13,\n    payee_node_key: 19,\n    purpose_commit_hash: 23,\n    expire_time: 6,\n    min_final_cltv_expiry: 24,\n    fallback_address: 9,\n    routing_info: 3,\n};\n// reverse the keys and values of TAGCODES and insert into TAGNAMES\nconst TAGNAMES = new Map();\nfor (const [k, v] of Object.entries(TAGCODES)) {\n    TAGNAMES.set(v, k);\n}\nconst bitcoinInfo = {\n    hashGenesisBlock: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f',\n    port: 8333,\n    portRpc: 8332,\n    protocol: { magic: 3652501241 },\n    bech32: 'bc',\n    seedsDns: [\n        'seed.bitcoin.sipa.be',\n        'dnsseed.bluematt.me',\n        'seed.bitcoinstats.com',\n        'seed.bitcoin.jonasschnelli.ch',\n        'seed.btc.petertodd.org',\n        'seed.bitcoin.sprovoost.nl',\n        'dnsseed.emzy.de',\n    ],\n    versions: { bip32: { private: 76066276, public: 76067358 }, bip44: 0, private: 128, public: 0, scripthash: 5 },\n    name: 'Bitcoin',\n    per1: 100000000,\n    unit: 'BTC',\n    messagePrefix: '\\\\u0018Bitcoin Signed Message:\\\\n',\n    testnet: false,\n    bip32: { public: 76067358, private: 76066276 },\n    pubKeyHash: 0,\n    scriptHash: 5,\n    wif: 128,\n    dustThreshold: null,\n};\nconst testnetInfo = {\n    hashGenesisBlock: '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943',\n    port: 18333,\n    portRpc: 18332,\n    protocol: { magic: 118034699 },\n    bech32: 'tb',\n    seedsDns: [\n        'testnet-seed.alexykot.me',\n        'testnet-seed.bitcoin.schildbach.de',\n        'testnet-seed.bitcoin.petertodd.org',\n        'testnet-seed.bluematt.me',\n    ],\n    versions: { bip32: { private: 70615956, public: 70617039 }, bip44: 1, private: 239, public: 111, scripthash: 196 },\n    name: 'Bitcoin',\n    per1: 100000000,\n    unit: 'BTC',\n    messagePrefix: '\\\\u0018Bitcoin Signed Message:\\\\n',\n    testnet: true,\n    bip32: { public: 70617039, private: 70615956 },\n    pubKeyHash: 111,\n    scriptHash: 196,\n    wif: 239,\n    dustThreshold: null,\n};\nfunction tagsItems(tags, tagName) {\n    let tag = tags.filter((item) => item.tagName === tagName);\n    let data = tag.length > 0 ? tag[0].data : undefined;\n    return data;\n}\nfunction tagsContainItem(tags, tagName) {\n    return tagsItems(tags, tagName) !== undefined;\n}\nfunction isDefined(t) {\n    if (t === undefined) {\n        throw new Error('unexpected undefined');\n    }\n    return t;\n}\nfunction decodeBolt11(paymentRequest) {\n    if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln') {\n        return new Error('Not a proper lightning payment request');\n    }\n    let decoded;\n    try {\n        decoded = bech32.decode(paymentRequest);\n    }\n    catch (err) {\n        if (!(err instanceof Error)) {\n            err = new Error(err);\n        }\n        return err;\n    }\n    let words = Uint8Array.from(decoded.words);\n    paymentRequest = paymentRequest.toLowerCase();\n    let sigWords = words.slice(-104);\n    // grabbing a copy of the words for later, words will be sliced as we parse.\n    let wordsNoSig = words.slice(0, -104);\n    words = words.slice(0, -104);\n    let sigBuffer = bech32.fromWords(sigWords);\n    let recoveryFlag = sigBuffer.slice(-1)[0];\n    sigBuffer = sigBuffer.slice(0, -1);\n    if (!(recoveryFlag in [0, 1, 2, 3]) || sigBuffer.length !== 64) {\n        return new Error('Signature is missing or incorrect');\n    }\n    // Without reverse lookups, can't say that the multipier at the end must\n    // have a number before it, so instead we parse, and if the second group\n    // doesn't have anything, there's a good chance the last letter of the\n    // coin type got captured by the third group, so just re-regex without\n    // the number.\n    let prefixMatches = decoded.prefix.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/);\n    if (prefixMatches && !prefixMatches[2])\n        prefixMatches = decoded.prefix.match(/^ln(\\S+)$/);\n    if (!prefixMatches) {\n        return new Error('Not a proper lightning payment request');\n    }\n    let coinType;\n    let coinNetwork;\n    let p1 = prefixMatches[1];\n    if (p1 === 'bc') {\n        coinType = 'bitcoin';\n        coinNetwork = bitcoinInfo;\n    }\n    else if (p1 == 'tb') {\n        coinType = 'testnet';\n        coinNetwork = testnetInfo;\n    }\n    else {\n        return new Error('Unknown coin bech32 prefix: ' + p1);\n    }\n    let value = prefixMatches[2];\n    let satoshis, millisatoshis;\n    if (value) {\n        let divisor = prefixMatches[3];\n        try {\n            satoshis = Number(hrpToSat(value + divisor));\n        }\n        catch { }\n        millisatoshis = hrpToMillisat(value + divisor);\n    }\n    else {\n        satoshis = undefined;\n        millisatoshis = undefined;\n    }\n    // reminder: left padded 0 bits\n    let timestamp = wordsToIntBE(words.slice(0, 7));\n    let timestampString = new Date(timestamp * 1000).toISOString();\n    words = words.slice(7); // trim off the left 7 words\n    let tags = [];\n    let tagName, parser, tagLength, tagWords;\n    // we have no tag count to go on, so just keep hacking off words\n    // until we have none.\n    while (words.length > 0) {\n        let tagCode = words[0];\n        tagName = TAGNAMES.get(tagCode) || unknownTagName;\n        parser = TAGPARSERS.get(tagCode) || getUnknownParser(tagCode);\n        words = words.slice(1);\n        tagLength = wordsToIntBE(words.slice(0, 2));\n        words = words.slice(2);\n        tagWords = words.slice(0, tagLength);\n        words = words.slice(tagLength);\n        // See: parsers for more comments\n        tags.push({\n            tagName,\n            data: parser(tagWords, coinNetwork),\n        });\n    }\n    let timeExpireDate, timeExpireDateString;\n    // be kind and provide an absolute expiration date.\n    // good for logs\n    let expirySeconds = 3600; // 1 hour\n    if (tagsContainItem(tags, isDefined(TAGNAMES.get(6)))) {\n        expirySeconds = isDefined(tagsItems(tags, isDefined(TAGNAMES.get(6))));\n    }\n    timeExpireDate = timestamp + expirySeconds;\n    timeExpireDateString = new Date(timeExpireDate * 1000).toISOString();\n    let toSign = buffutils.concat(buffutils.fromString(decoded.prefix), bech32.convert(wordsNoSig, 5, 8, true));\n    let payReqHash = sha256_1.default.digest(toSign);\n    let sig = signature_2.default.fromBytes(sigBuffer);\n    if (sig instanceof Error) {\n        return sig;\n    }\n    let sigPubkeyPoint = signature_1.ecdsaRecover(payReqHash, sig, recoveryFlag);\n    let payeeNodeKey = buffutils.toHex(new public_key_1.default(sigPubkeyPoint.x, sigPubkeyPoint.y).buffer);\n    const payee = tagsItems(tags, isDefined(TAGNAMES.get(19)));\n    if (payee && payee !== payeeNodeKey) {\n        return new Error('Lightning Payment Request signature pubkey does not match payee pubkey');\n    }\n    let finalResult = {\n        paymentRequest,\n        complete: true,\n        prefix: decoded.prefix,\n        wordsTemp: bech32.encode('temp', buffutils.concat(wordsNoSig, sigWords)),\n        coinType,\n        satoshis,\n        millisatoshis,\n        timestamp,\n        timestampString,\n        timeExpireDate,\n        timeExpireDateString,\n        payeeNodeKey,\n        signature: buffutils.toHex(sigBuffer),\n        recoveryFlag,\n        tags,\n    };\n    return orderKeys(finalResult);\n}\nexports.decodeBolt11 = decodeBolt11;\nfunction orderKeys(unorderedObj) {\n    let orderedObj = {};\n    Object.keys(unorderedObj)\n        .sort()\n        .forEach(key => {\n        orderedObj[key] = unorderedObj[key];\n    });\n    return orderedObj;\n}\nfunction satToHrp(satoshis) {\n    if (!satoshis.toString().match(/^\\d+$/)) {\n        throw new Error('satoshis must be an integer');\n    }\n    let millisatoshisBN = BigInt(satoshis);\n    return millisatToHrp(millisatoshisBN * BigInt(1000));\n}\nexports.satToHrp = satToHrp;\nfunction millisatToHrp(millisatoshis) {\n    if (!millisatoshis.toString().match(/^\\d+$/)) {\n        throw new Error('millisatoshis must be an integer');\n    }\n    let millisatoshisString = millisatoshis.toString();\n    let millisatoshisLength = millisatoshisString.length;\n    let divisorString, valueString;\n    if (millisatoshisLength > 11 && /0{11}$/.test(millisatoshisString)) {\n        divisorString = '';\n        valueString = (millisatoshis / MILLISATS_PER_BTC).toString();\n    }\n    else if (millisatoshisLength > 8 && /0{8}$/.test(millisatoshisString)) {\n        divisorString = 'm';\n        valueString = (millisatoshis / MILLISATS_PER_MILLIBTC).toString();\n    }\n    else if (millisatoshisLength > 5 && /0{5}$/.test(millisatoshisString)) {\n        divisorString = 'u';\n        valueString = (millisatoshis / MILLISATS_PER_MICROBTC).toString();\n    }\n    else if (millisatoshisLength > 2 && /0{2}$/.test(millisatoshisString)) {\n        divisorString = 'n';\n        valueString = (millisatoshis / MILLISATS_PER_NANOBTC).toString();\n    }\n    else {\n        divisorString = 'p';\n        valueString = (millisatoshis * PICOBTC_PER_MILLISATS).toString();\n    }\n    return valueString + divisorString;\n}\nexports.millisatToHrp = millisatToHrp;\nfunction unknownEncoder(data) {\n    data.words = bech32.decode(data.words).words;\n    return data;\n}\nconst TAGENCODERS = {\n    payment_hash: hexToWord,\n    description: textToWord,\n    payee_node_key: hexToWord,\n    purpose_commit_hash: purposeCommitEncoder,\n    expire_time: intBEToWords,\n    min_final_cltv_expiry: intBEToWords,\n    fallback_address: fallbackAddressEncoder,\n    routing_info: routingInfoEncoder,\n};\nfunction hexToWord(hex) {\n    let buffer = buffutils.fromHex(hex);\n    if (buffer instanceof Error) {\n        throw new Error('invalid hex');\n    }\n    return bech32.toWords(buffer);\n}\nfunction textToWord(text) {\n    let buffer = buffutils.fromString(text);\n    let words = bech32.toWords(buffer);\n    return words;\n}\n// if text, return the sha256 hash of the text as words.\n// if hex, return the words representation of that data.\nfunction purposeCommitEncoder(data) {\n    let buffer = buffutils.fromHex(data);\n    if (buffer instanceof Error) {\n        buffer = sha256_1.default.digest(buffutils.fromString(data));\n    }\n    return bech32.toWords(buffer);\n}\n// the code is the witness version OR 17 for P2PKH OR 18 for P2SH\n// anything besides code 17 or 18 should be bech32 encoded address.\n// 1 word for the code, and right pad with 0 if necessary for the addressHash\n// (address parsing for encode is done in the encode function)\nfunction fallbackAddressEncoder(data, network) {\n    return buffutils.concat(Uint8Array.of(data.code), hexToWord(data.addressHash));\n}\n// routing info is encoded first as a large buffer\n// 51 bytes for each channel\n// 33 byte pubkey, 8 byte short_channel_id, 4 byte millisatoshi base fee (left padded)\n// 4 byte fee proportional millionths and a 2 byte left padded CLTV expiry delta.\n// after encoding these 51 byte chunks and concatenating them\n// convert to words right padding 0 bits.\nfunction routingInfoEncoder(datas) {\n    let buffer = Buffer.from([]);\n    datas.forEach(data => {\n        const pubkeybuff = buffutils.fromHex(data.pubkey);\n        if (pubkeybuff instanceof Error) {\n            throw new Error('data.pubkey was not hex');\n        }\n        const shortChannelBuff = buffutils.fromHex(data.short_channel_id);\n        if (shortChannelBuff instanceof Error) {\n            throw new Error('data.hexToBuffer was not hex');\n        }\n        buffer = Buffer.concat([buffer, pubkeybuff]);\n        buffer = Buffer.concat([buffer, shortChannelBuff]);\n        buffer = Buffer.concat([buffer, Buffer.from([0, 0, 0].concat(...intBEToWords(data.fee_base_msat, 8)).slice(-4))]);\n        buffer = Buffer.concat([\n            buffer,\n            Buffer.from([0, 0, 0].concat(...intBEToWords(data.fee_proportional_millionths, 8)).slice(-4)),\n        ]);\n        buffer = Buffer.concat([buffer, Buffer.from([0].concat(...intBEToWords(data.cltv_expiry_delta, 8)).slice(-2))]);\n    });\n    return bech32.toWords(buffer);\n}\nfunction encodeBolt11(paymentRequest) {\n    let data = { ...paymentRequest }; // make a copy, but careful as it's not a deep copy\n    data.tags = [...paymentRequest.tags]; // deep copy the tags\n    let canReconstruct = !(data.signature === undefined || data.recoveryFlag === undefined);\n    // if no cointype is defined, set to testnet\n    let coinTypeObj;\n    if (data.coinType === undefined && !canReconstruct) {\n        data.coinType = 'testnet';\n        coinTypeObj = testnetInfo;\n    }\n    else if (data.coinType === undefined && canReconstruct) {\n        throw new Error('Need coinType for proper payment request reconstruction');\n    }\n    else {\n        if (data.coinType === 'bitcoin') {\n            coinTypeObj = bitcoinInfo;\n        }\n        else if (data.coinType === 'testnet') {\n            coinTypeObj = testnetInfo;\n        }\n        else {\n            throw new Error('Unknown coin type: ' + data.coinType);\n        }\n    }\n    // use current time as default timestamp (seconds)\n    if (data.timestamp === undefined && !canReconstruct) {\n        data.timestamp = Math.floor(new Date().getTime() / 1000);\n    }\n    else if (data.timestamp === undefined && canReconstruct) {\n        throw new Error('Need timestamp for proper payment request reconstruction');\n    }\n    if (data.tags === undefined)\n        throw new Error('Payment Requests need tags array');\n    // If no payment hash, fail\n    if (!tagsContainItem(data.tags, isDefined(TAGNAMES.get(1)))) {\n        throw new Error('Lightning Payment Request needs a payment hash');\n    }\n    // If no description or purpose commit hash/message, fail\n    if (!tagsContainItem(data.tags, isDefined(TAGNAMES.get(13))) &&\n        !tagsContainItem(data.tags, isDefined(TAGNAMES.get(23)))) {\n        data.tags.push({\n            tagName: isDefined(TAGNAMES.get(13)),\n            data: '',\n        });\n    }\n    // If a description exists, check to make sure the buffer isn't greater than\n    // 639 bytes long, since 639 * 8 / 5 = 1023 words (5 bit) when padded\n    if (tagsContainItem(data.tags, isDefined(TAGNAMES.get(13))) &&\n        Buffer.from(tagsItems(data.tags, isDefined(TAGNAMES.get(13))), 'utf8').length > 639) {\n        throw new Error('Description is too long: Max length 639 bytes');\n    }\n    // if there's no expire time, and it is not reconstructing (must have private key)\n    // default to adding a 3600 second expire time (1 hour)\n    if (!tagsContainItem(data.tags, isDefined(TAGNAMES.get(6))) && !canReconstruct) {\n        data.tags.push({\n            tagName: isDefined(TAGNAMES.get(6)),\n            data: 3600,\n        });\n    }\n    // if there's no minimum cltv time, and it is not reconstructing (must have private key)\n    // default to adding a 9 block minimum cltv time (90 minutes for bitcoin)\n    if (!tagsContainItem(data.tags, isDefined(TAGNAMES.get(24))) && !canReconstruct) {\n        data.tags.push({\n            tagName: isDefined(TAGNAMES.get(24)),\n            data: 9,\n        });\n    }\n    let nodePublicKey, tagNodePublicKey;\n    // If there is a payee_node_key tag convert to buffer\n    if (tagsContainItem(data.tags, isDefined(TAGNAMES.get(19)))) {\n        tagNodePublicKey = buffutils.fromHex(tagsItems(data.tags, isDefined(TAGNAMES.get(19))));\n        if (tagNodePublicKey instanceof Error) {\n            throw new Error('tag19 was not hex encoded');\n        }\n    }\n    // If there is payeeNodeKey attribute, convert to buffer\n    if (data.payeeNodeKey) {\n        nodePublicKey = buffutils.fromHex(data.payeeNodeKey);\n        if (nodePublicKey instanceof Error) {\n            throw new Error('payeeNodeKey was not hex encoded');\n        }\n    }\n    if (nodePublicKey && tagNodePublicKey && !buffutils.equal(tagNodePublicKey, nodePublicKey)) {\n        throw new Error('payeeNodeKey and tag payee node key do not match');\n    }\n    // in case we have one or the other, make sure it's in nodePublicKey\n    nodePublicKey = nodePublicKey || tagNodePublicKey;\n    if (nodePublicKey) {\n        data.payeeNodeKey = buffutils.toHex(nodePublicKey);\n    }\n    let code, addressHash, address;\n    // If there is a fallback address tag we must check it is valid\n    if (tagsContainItem(data.tags, isDefined(TAGNAMES.get(9)))) {\n        let addrData = tagsItems(data.tags, isDefined(TAGNAMES.get(9)));\n        // Most people will just provide address so Hash and code will be undefined here\n        address = addrData.address;\n        addressHash = addrData.addressHash;\n        code = addrData.code;\n        if (addressHash === undefined || code === undefined) {\n            let bech32addr, base58addr;\n            try {\n                const payload = bech32.decode(address);\n                bech32addr = {\n                    hash: bech32.fromWords(payload.words.slice(1)),\n                    version: payload.words[0],\n                    prefix: payload.prefix,\n                };\n                code = bech32addr.version;\n                addressHash = bech32addr.hash;\n            }\n            catch (e) {\n                try {\n                    const payload = bs58check.decode(address); // this throws\n                    if (payload.length < 21)\n                        throw new Error(address + ' is too short');\n                    if (payload.length > 21)\n                        throw new Error(address + ' is too long');\n                    base58addr = {\n                        version: payload[0],\n                        hash: payload.slice(1),\n                    };\n                    if (base58addr.version === coinTypeObj.pubKeyHash) {\n                        code = 17;\n                    }\n                    else if (base58addr.version === coinTypeObj.scriptHash) {\n                        code = 18;\n                    }\n                    else {\n                        throw new Error('unrecognized address version: ' + base58addr.version);\n                    }\n                    addressHash = base58addr.hash;\n                }\n                catch (f) {\n                    throw new Error('Fallback address (' + address + ') is unknown');\n                }\n            }\n            if (bech32addr && !(bech32addr.version !== 0)) {\n                throw new Error('Fallback address witness version is unknown');\n            }\n            if (bech32addr && bech32addr.prefix !== coinTypeObj.bech32) {\n                throw new Error('Fallback address network type does not match payment request network type');\n            }\n            if (base58addr &&\n                base58addr.version !== coinTypeObj.pubKeyHash &&\n                base58addr.version !== coinTypeObj.scriptHash) {\n                throw new Error('Fallback address version (base58) is unknown or the network type is incorrect');\n            }\n            // FIXME: If addressHash or code is missing, add them to the original Object\n            // after parsing the address value... this changes the actual attributes of the data object.\n            // Not very clean.\n            // Without this, a person can not specify a fallback address tag with only the address key.\n            addrData.addressHash = buffutils.toHex(addressHash);\n            addrData.code = code;\n        }\n    }\n    // If there is route info tag, check that each route has all 4 necessary info\n    if (tagsContainItem(data.tags, isDefined(TAGNAMES.get(3)))) {\n        let routingInfo = tagsItems(data.tags, isDefined(TAGNAMES.get(3)));\n        routingInfo.forEach((route) => {\n            if (route.pubkey === undefined ||\n                route.short_channel_id === undefined ||\n                route.fee_base_msat === undefined ||\n                route.fee_proportional_millionths === undefined ||\n                route.cltv_expiry_delta === undefined) {\n                throw new Error('Routing info is incomplete');\n            }\n            if (ecc.Point.fromHex(route.pubkey) instanceof Error) {\n                throw new Error('Routing info pubkey is not a valid pubkey');\n            }\n            let shortId = buffutils.fromHex(route.short_channel_id);\n            if (shortId instanceof Error || shortId.length !== 8) {\n                throw new Error('Routing info short channel id must be 8 bytes');\n            }\n            if (typeof route.fee_base_msat !== 'number' || Math.floor(route.fee_base_msat) !== route.fee_base_msat) {\n                throw new Error('Routing info fee base msat is not an integer');\n            }\n            if (typeof route.fee_proportional_millionths !== 'number' ||\n                Math.floor(route.fee_proportional_millionths) !== route.fee_proportional_millionths) {\n                throw new Error('Routing info fee proportional millionths is not an integer');\n            }\n            if (typeof route.cltv_expiry_delta !== 'number' ||\n                Math.floor(route.cltv_expiry_delta) !== route.cltv_expiry_delta) {\n                throw new Error('Routing info cltv expiry delta is not an integer');\n            }\n        });\n    }\n    let prefix = 'ln';\n    prefix += coinTypeObj.bech32;\n    let hrpString;\n    // calculate the smallest possible integer (removing zeroes) and add the best\n    // divisor (m = milli, u = micro, n = nano, p = pico)\n    if (data.millisatoshis && data.satoshis) {\n        hrpString = millisatToHrp(data.millisatoshis);\n        let hrpStringSat = satToHrp(BigInt(data.satoshis));\n        if (hrpStringSat !== hrpString) {\n            throw new Error('satoshis and millisatoshis do not match');\n        }\n    }\n    else if (data.millisatoshis) {\n        hrpString = millisatToHrp(data.millisatoshis);\n    }\n    else if (data.satoshis) {\n        hrpString = satToHrp(BigInt(data.satoshis));\n    }\n    else {\n        hrpString = '';\n    }\n    // bech32 human readable part is lnbc2500m (ln + coinbech32 + satoshis (optional))\n    // lnbc or lntb would be valid as well. (no value specified)\n    prefix += hrpString;\n    // timestamp converted to 5 bit number array (left padded with 0 bits, NOT right padded)\n    let timestampWords = intBEToWords(data.timestamp);\n    let tags = data.tags;\n    let tagWords = Uint8Array.from([]);\n    tags.forEach(tag => {\n        const possibleTagNames = Object.keys(TAGENCODERS);\n        if (canReconstruct)\n            possibleTagNames.push(unknownTagName);\n        // check if the tagName exists in the encoders object, if not throw Error.\n        if (possibleTagNames.indexOf(tag.tagName) === -1) {\n            throw new Error('Unknown tag key: ' + tag.tagName);\n        }\n        let words;\n        if (tag.tagName !== unknownTagName) {\n            // each tag starts with 1 word code for the tag\n            tagWords = buffutils.concat(tagWords, Uint8Array.of(TAGCODES[tag.tagName]));\n            const encoder = TAGENCODERS[tag.tagName];\n            words = encoder(tag.data);\n        }\n        else {\n            let result = unknownEncoder(tag.data);\n            tagWords = buffutils.concat(tagWords, result.tagCode);\n            words = result.words;\n        }\n        // after the tag code, 2 words are used to store the length (in 5 bit words) of the tag data\n        // (also left padded, most integers are left padded while buffers are right padded)\n        tagWords = buffutils.concat(tagWords, buffutils.slice(buffutils.concat(Uint8Array.of(0), intBEToWords(words.length)), -2));\n        // then append the tag data words\n        tagWords = buffutils.concat(tagWords, words);\n    });\n    // the data part of the bech32 is TIMESTAMP || TAGS || SIGNATURE\n    // currently dataWords = TIMESTAMP || TAGS\n    let dataWords = buffutils.concat(timestampWords, tagWords);\n    // the preimage for the signing data is the buffer of the prefix concatenated\n    // with the buffer conversion of the data words excluding the signature\n    // (right padded with 0 bits)\n    //Buffer.concat([Buffer.from(prefix, 'utf8'), Buffer.from(convert(dataWords, 5, 8))])\n    let toSign = buffutils.concat(buffutils.fromString(prefix), bech32.convert(dataWords, 5, 8, true));\n    // single SHA256 hash for the signature\n    let payReqHash = sha256_1.default.digest(toSign);\n    // signature is 64 bytes (32 byte r value and 32 byte s value concatenated)\n    // PLUS one extra byte appended to the right with the recoveryID in [0,1,2,3]\n    // Then convert to 5 bit words with right padding 0 bits.\n    let sigWords;\n    if (canReconstruct) {\n        /* Since BOLT11 does not require a payee_node_key tag in the specs,\n        most parsers will have to recover the pubkey from the signature\n        To ensure the tag data has been provided in the right order etc.\n        we should check that the data we got and the node key given match when\n        reconstructing a payment request from given signature and recoveryID.\n        However, if a privatekey is given, the caller is the privkey owner.\n        Earlier we check if the private key matches the payee node key IF they\n        gave one. */\n        if (nodePublicKey) {\n            //let recoveredPubkey = secp256k1.recover(payReqHash, Buffer.from(data.signature, 'hex'), data.recoveryFlag, true)\n            if (!data.signature || data.recoveryFlag === undefined) {\n                throw new Error('expected signature/recoveryFlag to recover pubkey');\n            }\n            const sig = ecc.Signature.fromHex(data.signature);\n            if (sig instanceof Error) {\n                throw new Error('expected signature to be valid hex');\n            }\n            let recoveredPubkey = ecc.Point.toBytes(signature_1.ecdsaRecover(payReqHash, sig, data.recoveryFlag));\n            if (nodePublicKey && !buffutils.equal(nodePublicKey, recoveredPubkey)) {\n                throw new Error('Signature, message, and recoveryID did not produce the same pubkey as payeeNodeKey');\n            }\n            sigWords = hexToWord(data.signature + '0' + data.recoveryFlag);\n        }\n        else {\n            throw new Error('Reconstruction with signature and recoveryID requires payeeNodeKey to verify correctness of input data.');\n        }\n    }\n    if (sigWords) {\n        dataWords = buffutils.concat(dataWords, sigWords);\n    }\n    if (data.timestamp === undefined) {\n        throw new Error('expected timestamp');\n    }\n    const tags6Item = tagsItems(data.tags, isDefined(TAGNAMES.get(6)));\n    if (tags6Item !== undefined) {\n        data.timeExpireDate = data.timestamp + tags6Item;\n        data.timeExpireDateString = new Date(data.timeExpireDate * 1000).toISOString();\n    }\n    data.timestampString = new Date(data.timestamp * 1000).toISOString();\n    data.prefix = prefix;\n    data.wordsTemp = bech32.encode('temp', dataWords);\n    data.complete = !!sigWords;\n    if (!data.complete) {\n        throw new Error('can not encode incomplete');\n    }\n    return bech32.encode(prefix, dataWords);\n}\nexports.encodeBolt11 = encodeBolt11;\nfunction intBEToWords(intBE = 0, bits = 5) {\n    let words = [];\n    intBE = Math.floor(intBE);\n    if (intBE === 0)\n        return Uint8Array.of(0);\n    while (intBE > 0) {\n        words.push(intBE & (Math.pow(2, bits) - 1));\n        intBE = Math.floor(intBE / Math.pow(2, bits));\n    }\n    return Uint8Array.from(words.reverse());\n}\n//# sourceMappingURL=bolt11.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst blinded_message_1 = require(\"./blinded-message\");\nconst hash_1 = require(\"./hash\");\nconst public_key_1 = require(\"./public-key\");\nconst signature_1 = require(\"./signature\");\nconst magnitude_1 = require(\"./magnitude\");\nclass ClaimRequest {\n    constructor(claimableHash, coinRequests, authorization) {\n        this.claimableHash = claimableHash;\n        this.coinRequests = coinRequests;\n        this.authorization = authorization;\n    }\n    static newAuthorized(claimableHash, coinRequests, claimantPrivateKey) {\n        const hash = ClaimRequest.hashOf(claimableHash, coinRequests);\n        const authorization = signature_1.default.compute(hash.buffer, claimantPrivateKey);\n        return new ClaimRequest(claimableHash, coinRequests, authorization);\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'object') {\n            return new Error('ClaimRequest.fromPOD expected an object');\n        }\n        const claimableHash = hash_1.default.fromPOD(data.claimableHash);\n        if (claimableHash instanceof Error) {\n            return claimableHash;\n        }\n        if (!Array.isArray(data.coinRequests)) {\n            return new Error('ClaimRequest.fromPOD expected an array for coinRequests');\n        }\n        const coinRequests = [];\n        for (const coin of data.coinRequests) {\n            const blindingNonce = public_key_1.default.fromPOD(coin.blindingNonce);\n            if (blindingNonce instanceof Error) {\n                return blindingNonce;\n            }\n            const blindedOwner = blinded_message_1.default.fromPOD(coin.blindedOwner);\n            if (blindedOwner instanceof Error) {\n                return blindedOwner;\n            }\n            const magnitude = magnitude_1.default.fromPOD(coin.magnitude);\n            if (magnitude instanceof Error) {\n                return magnitude;\n            }\n            coinRequests.push({ blindingNonce, blindedOwner, magnitude });\n        }\n        const authorization = signature_1.default.fromPOD(data.authorization);\n        if (authorization instanceof Error) {\n            return authorization;\n        }\n        return new ClaimRequest(claimableHash, coinRequests, authorization);\n    }\n    static hashOf(claimableHash, coinRequests) {\n        const h = hash_1.default.newBuilder('ClaimRequest');\n        h.update(claimableHash.buffer);\n        for (const cc of coinRequests) {\n            h.update(cc.blindedOwner.buffer);\n            h.update(cc.blindingNonce.buffer);\n            h.update(cc.magnitude.buffer);\n        }\n        return h.digest();\n    }\n    hash() {\n        return ClaimRequest.hashOf(this.claimableHash, this.coinRequests);\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            authorization: this.authorization.toPOD(),\n            claimableHash: this.claimableHash.toPOD(),\n            coinRequests: this.coinRequests.map(cr => ({\n                blindedOwner: cr.blindedOwner.toPOD(),\n                blindingNonce: cr.blindingNonce.toPOD(),\n                magnitude: cr.magnitude.toPOD(),\n            })),\n        };\n    }\n    // how much is being claimed\n    amount() {\n        let n = 0;\n        for (const coinRequest of this.coinRequests) {\n            n += coinRequest.magnitude.toAmount();\n        }\n        return n;\n    }\n}\nexports.default = ClaimRequest;\n//# sourceMappingURL=claim-request.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hookout_1 = require(\"./hookout\");\nconst fee_bump_1 = require(\"./fee-bump\");\nconst lightning_payment_1 = require(\"./lightning-payment\");\nconst lightning_invoice_1 = require(\"./lightning-invoice\");\nconst hookin_1 = require(\"./hookin\");\nfunction claimableToPOD(c) {\n    if (c instanceof hookout_1.default) {\n        return { kind: 'Hookout', ...c.toPOD() };\n    }\n    else if (c instanceof fee_bump_1.default) {\n        return { kind: 'FeeBump', ...c.toPOD() };\n    }\n    else if (c instanceof lightning_payment_1.default) {\n        return { kind: 'LightningPayment', ...c.toPOD() };\n    }\n    else if (c instanceof lightning_invoice_1.default) {\n        return { kind: 'LightningInvoice', ...c.toPOD() };\n    }\n    else if (c instanceof hookin_1.default) {\n        return { kind: 'Hookin', ...c.toPOD() };\n    }\n    else {\n        const _ = c;\n        throw new Error('unknown claimable kind');\n    }\n}\nexports.claimableToPOD = claimableToPOD;\nfunction claimableFromPOD(obj) {\n    if (typeof obj !== 'object') {\n        return new Error('claimableFromPOD expected an object');\n    }\n    if (typeof obj.kind !== 'string') {\n        return new Error('claimableFromPOD expected a string kind');\n    }\n    const parser = parserFromKind(obj.kind);\n    if (!parser) {\n        return new Error('claimableFromPODcouldnt handle that kind');\n    }\n    const c = parser(obj);\n    if (c instanceof Error) {\n        return c;\n    }\n    if (c.hash().toPOD() !== obj.hash) {\n        return new Error('hash did not match');\n    }\n    return c;\n}\nexports.claimableFromPOD = claimableFromPOD;\nfunction parserFromKind(kind) {\n    switch (kind) {\n        case 'Hookout':\n            return hookout_1.default.fromPOD;\n        case 'FeeBump':\n            return fee_bump_1.default.fromPOD;\n        case 'LightningPayment':\n            return lightning_payment_1.default.fromPOD;\n        case 'LightningInvoice':\n            return lightning_invoice_1.default.fromPOD;\n        case 'Hookin':\n            return hookin_1.default.fromPOD;\n    }\n}\nexports.parserFromKind = parserFromKind;\n// export function podToClaimable(obj: any): Claimable | Error {\n//   if (typeof obj !== 'object' || typeof obj.kind !== 'string') {\n//     return new Error('parseTransfer expected an object with a kind to parse');\n//   }\n//   const parser = parsers.get(obj.kind);\n//   if (!parser) {\n//     return new Error('could not parse a: ' + obj.kind);\n//   }\n//   return parser(obj);\n// }\n//# sourceMappingURL=claimable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hash_1 = require(\"./hash\");\nconst public_key_1 = require(\"./public-key\");\nconst signature_1 = require(\"./signature\");\nconst magnitude_1 = require(\"./magnitude\");\nconst Buffutils = require(\"./util/buffutils\");\nclass Coin {\n    constructor(owner, magnitude, receipt) {\n        this.owner = owner;\n        this.magnitude = magnitude;\n        this.receipt = receipt;\n    }\n    static fromPOD(data) {\n        const owner = public_key_1.default.fromPOD(data.owner);\n        if (owner instanceof Error) {\n            return owner;\n        }\n        const magnitude = magnitude_1.default.fromPOD(data.magnitude);\n        if (magnitude instanceof Error) {\n            return magnitude;\n        }\n        const receipt = signature_1.default.fromPOD(data.receipt);\n        if (receipt instanceof Error) {\n            return receipt;\n        }\n        const c = new Coin(owner, magnitude, receipt);\n        if (c.hash().toPOD() !== data.hash) {\n            return new Error('hash did not match');\n        }\n        return c;\n    }\n    get buffer() {\n        return Buffutils.concat(this.owner.buffer, this.magnitude.buffer, this.receipt.buffer);\n    }\n    hash() {\n        return hash_1.default.fromMessage('Coin', this.buffer);\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            receipt: this.receipt.toPOD(),\n            magnitude: this.magnitude.toPOD(),\n            owner: this.owner.toPOD(),\n        };\n    }\n    get amount() {\n        return this.magnitude.toAmount();\n    }\n}\nexports.default = Coin;\n//# sourceMappingURL=coin.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst public_key_1 = require(\"./public-key\");\nconst hash_1 = require(\"./hash\");\nconst bech32 = require(\"./util/bech32\");\nconst Buffutils = require(\"./util/buffutils\");\nclass CustodianInfo {\n    constructor(acknowledgementKey, currency, fundingKey, blindCoinKeys) {\n        this.acknowledgementKey = acknowledgementKey;\n        this.currency = currency;\n        this.fundingKey = fundingKey;\n        this.blindCoinKeys = blindCoinKeys;\n    }\n    hash() {\n        return hash_1.default.fromMessage('Custodian', this.acknowledgementKey.buffer, Buffutils.fromUint32(this.currency.length), Buffutils.fromString(this.currency), this.fundingKey.buffer, ...this.blindCoinKeys.map(bk => bk.buffer));\n    }\n    // 4 letter code for using in an Address\n    prefix() {\n        const hash = this.hash().buffer;\n        return (bech32.ALPHABET[hash[0] % 32] +\n            bech32.ALPHABET[hash[1] % 32] +\n            bech32.ALPHABET[hash[2] % 32] +\n            bech32.ALPHABET[hash[3] % 32]);\n    }\n    toPOD() {\n        return {\n            acknowledgementKey: this.acknowledgementKey.toPOD(),\n            currency: this.currency,\n            fundingKey: this.fundingKey.toPOD(),\n            blindCoinKeys: this.blindCoinKeys.map(bk => bk.toPOD()),\n        };\n    }\n    static fromPOD(d) {\n        if (typeof d !== 'object') {\n            return new Error('custodian fromPOD expected an object');\n        }\n        const acknowledgementKey = public_key_1.default.fromPOD(d.acknowledgementKey);\n        if (acknowledgementKey instanceof Error) {\n            return acknowledgementKey;\n        }\n        const currency = d.currency;\n        if (typeof currency !== 'string') {\n            return new Error('custodian expected a stringified currency');\n        }\n        const fundingKey = public_key_1.default.fromPOD(d.fundingKey);\n        if (fundingKey instanceof Error) {\n            return fundingKey;\n        }\n        if (!Array.isArray(d.blindCoinKeys) || d.blindCoinKeys.length !== 31) {\n            return new Error('custodian expected an 31-length array for blindCoinKeys');\n        }\n        const blindCoinKeys = [];\n        for (const bkstr of d.blindCoinKeys) {\n            const bk = public_key_1.default.fromPOD(bkstr);\n            if (bk instanceof Error) {\n                return bk;\n            }\n            blindCoinKeys.push(bk);\n        }\n        return new CustodianInfo(acknowledgementKey, currency, fundingKey, blindCoinKeys);\n    }\n}\nexports.default = CustodianInfo;\n//# sourceMappingURL=custodian-info.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Buffutils = require(\"./util/buffutils\");\nconst hash_1 = require(\"./hash\");\nconst assert = require(\"./util/assert\");\nconst abstract_transfer_1 = require(\"./abstract-transfer\");\nclass FeeBump extends abstract_transfer_1.default {\n    constructor(transferData, txid) {\n        super(transferData);\n        this.txid = txid;\n        assert.equal(txid.length, 32);\n        this.txid = txid;\n    }\n    static fromPOD(data) {\n        const transferData = abstract_transfer_1.parseTransferData(data);\n        if (transferData instanceof Error) {\n            throw transferData;\n        }\n        const txid = Buffutils.fromHex(data.txid, 32);\n        if (txid instanceof Error) {\n            return new Error('FeeBump.fromPOD invalid txid');\n        }\n        return new FeeBump(transferData, txid);\n    }\n    get kind() {\n        return 'FeeBump';\n    }\n    toPOD() {\n        return {\n            ...super.toPOD(),\n            txid: Buffutils.toHex(this.txid),\n        };\n    }\n    static hashOf(transferHash, txid) {\n        return hash_1.default.fromMessage('FeeBump', transferHash.buffer, txid);\n    }\n    hash() {\n        return FeeBump.hashOf(abstract_transfer_1.default.transferHash(this), this.txid);\n    }\n}\nexports.default = FeeBump;\n//# sourceMappingURL=fee-bump.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"./util/assert\");\nconst bech32 = require(\"./util/bech32\");\nconst sha256_1 = require(\"./util/bcrypto/sha256\");\nconst Buffutil = require(\"./util/buffutils\");\nconst serializedPrefix = 'hsmp'; // hash moneypot\nclass Hash {\n    constructor(buff) {\n        assert.equal(buff.length, 32);\n        this.buffer = buff;\n    }\n    // actually hashes a message(s)\n    static fromMessage(prefix, ...message) {\n        const buff = sha256_1.default.mac(Buffutil.fromString(prefix), Buffutil.concat(...message));\n        return new Hash(buff);\n    }\n    static newBuilder(prefix) {\n        // this can be optimized later:\n        const parts = [];\n        return new (class {\n            update(message) {\n                parts.push(message);\n            }\n            digest() {\n                return Hash.fromMessage(prefix, ...parts);\n            }\n        })();\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'string') {\n            return new Error('Hash.fromPOD expected string');\n        }\n        const { prefix, words } = bech32.decode(data);\n        if (prefix !== serializedPrefix) {\n            return new Error('hash.fromPOD expected prefix: ' + serializedPrefix + ' but got ' + prefix);\n        }\n        const bytes = bech32.fromWords(words);\n        return new Hash(bytes);\n    }\n    toPOD() {\n        const words = bech32.toWords(this.buffer);\n        return bech32.encode(serializedPrefix, words);\n    }\n}\nexports.default = Hash;\n//# sourceMappingURL=hash.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hash_1 = require(\"./hash\");\nconst private_key_1 = require(\"./private-key\");\nconst public_key_1 = require(\"./public-key\");\nconst POD = require(\"./pod\");\nconst buffutils = require(\"./util/buffutils\");\nclass Hookin {\n    constructor(txid, vout, amount, claimant, bitcoinAddress) {\n        this.txid = txid;\n        this.vout = vout;\n        this.amount = amount;\n        this.claimant = claimant;\n        this.bitcoinAddress = bitcoinAddress;\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'object') {\n            return new Error('hookin expected an object');\n        }\n        const txid = buffutils.fromHex(data.txid, 32);\n        if (txid instanceof Error) {\n            return txid;\n        }\n        const vout = data.vout;\n        if (!Number.isSafeInteger(vout) || vout < 0 || vout > 65536) {\n            return new Error('hookin was given an invalid vout');\n        }\n        const amount = data.amount;\n        if (!POD.isAmount(amount)) {\n            return new Error('invalid amount for hookin');\n        }\n        const claimant = public_key_1.default.fromPOD(data.claimant);\n        if (claimant instanceof Error) {\n            return claimant;\n        }\n        const bitcoinAddress = data.bitcoinAddress;\n        if (typeof bitcoinAddress !== 'string') {\n            return new Error('hookin expected a bitcoin address');\n        }\n        return new Hookin(txid, vout, amount, claimant, bitcoinAddress);\n    }\n    static hashOf(txid, vout, amount, claimant, bitcoinAddress) {\n        const b = hash_1.default.newBuilder('Hookin');\n        b.update(txid);\n        b.update(buffutils.fromUint32(vout));\n        b.update(buffutils.fromUint64(amount));\n        b.update(claimant.buffer);\n        b.update(buffutils.fromString(bitcoinAddress));\n        return b.digest();\n    }\n    hash() {\n        return Hookin.hashOf(this.txid, this.vout, this.amount, this.claimant, this.bitcoinAddress);\n    }\n    get kind() {\n        return 'Hookin';\n    }\n    get claimableAmount() {\n        // a hookin by itself has no claimable value, it's only after we have some status updates for it being sufficiently confirmed\n        return 0;\n    }\n    getTweak() {\n        const bytes = hash_1.default.fromMessage('tweak', this.claimant.buffer).buffer;\n        const pk = private_key_1.default.fromBytes(bytes);\n        if (pk instanceof Error) {\n            throw pk;\n        }\n        return pk;\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            amount: this.amount,\n            claimant: this.claimant.toPOD(),\n            txid: buffutils.toHex(this.txid),\n            vout: this.vout,\n            bitcoinAddress: this.bitcoinAddress,\n        };\n    }\n}\nexports.default = Hookin;\n//# sourceMappingURL=hookin.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Buffutils = require(\"./util/buffutils\");\nconst hash_1 = require(\"./hash\");\nconst abstract_transfer_1 = require(\"./abstract-transfer\");\nclass Hookout extends abstract_transfer_1.default {\n    constructor(td, bitcoinAddress, priority, rbf) {\n        super(td);\n        this.bitcoinAddress = bitcoinAddress;\n        this.priority = priority;\n        this.rbf = rbf;\n    }\n    static fromPOD(data) {\n        const transferData = abstract_transfer_1.parseTransferData(data);\n        if (transferData instanceof Error) {\n            return transferData;\n        }\n        const rbf = data.rbf;\n        if (typeof rbf !== 'boolean') {\n            return new Error('Hookout.fromPOD invalid rbf');\n        }\n        const bitcoinAddress = data.bitcoinAddress;\n        if (typeof bitcoinAddress !== 'string') {\n            return new Error('Hookout.fromPOD invalid bitcoin address');\n        }\n        const priority = data.priority;\n        if (['CUSTOM', 'IMMEDIATE', 'BATCH', 'FREE'].indexOf(priority) === -1) {\n            return new Error('Unrecognized priority');\n        }\n        return new Hookout(transferData, bitcoinAddress, priority, rbf);\n    }\n    get kind() {\n        return 'Hookout';\n    }\n    toPOD() {\n        return {\n            ...super.toPOD(),\n            bitcoinAddress: this.bitcoinAddress,\n            priority: this.priority,\n            rbf: this.rbf,\n        };\n    }\n    static hashOf(transferDataHash, bitcoinAddress, priority) {\n        return hash_1.default.fromMessage('Hookout', transferDataHash.buffer, Buffutils.fromString(bitcoinAddress), Buffutils.fromString(priority[0]) // first letter must be unique\n        );\n    }\n    hash() {\n        return Hookout.hashOf(abstract_transfer_1.default.transferHash(this), this.bitcoinAddress, this.priority);\n    }\n}\nexports.default = Hookout;\n//# sourceMappingURL=hookout.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Buffutils = require(\"./util/buffutils\");\nexports.Buffutils = Buffutils;\nconst POD = require(\"./pod\");\nexports.POD = POD;\n// types\nvar blinded_message_1 = require(\"./blinded-message\");\nexports.BlindedMessage = blinded_message_1.default;\nvar blinded_signature_1 = require(\"./blinded-signature\");\nexports.BlindedSignature = blinded_signature_1.default;\nvar hash_1 = require(\"./hash\");\nexports.Hash = hash_1.default;\nvar private_key_1 = require(\"./private-key\");\nexports.PrivateKey = private_key_1.default;\nvar public_key_1 = require(\"./public-key\");\nexports.PublicKey = public_key_1.default;\nvar signature_1 = require(\"./signature\");\nexports.Signature = signature_1.default;\n// models\nvar coin_1 = require(\"./coin\");\nexports.Coin = coin_1.default;\nconst custodian_info_1 = require(\"./custodian-info\");\nexports.CustodianInfo = custodian_info_1.default;\nvar hookin_1 = require(\"./hookin\");\nexports.Hookin = hookin_1.default;\nconst hookout_1 = require(\"./hookout\");\nexports.Hookout = hookout_1.default;\nconst lightning_payment_1 = require(\"./lightning-payment\");\nexports.LightningPayment = lightning_payment_1.default;\nconst fee_bump_1 = require(\"./fee-bump\");\nexports.FeeBump = fee_bump_1.default;\nvar magnitude_1 = require(\"./magnitude\");\nexports.Magnitude = magnitude_1.default;\nvar abstract_transfer_1 = require(\"./abstract-transfer\");\nexports.AbstractTransfer = abstract_transfer_1.default;\n__export(require(\"./claimable\"));\n__export(require(\"./status\"));\nvar compute_claimable_remaining_1 = require(\"./status/compute-claimable-remaining\");\nexports.computeClaimableRemaining = compute_claimable_remaining_1.default;\n// blind functions\n__export(require(\"./blind\"));\n// helper coin function\n__export(require(\"./util/coins\"));\n__export(require(\"./bolt11\"));\n__export(require(\"./util/bitcoin-address\"));\nvar claim_request_1 = require(\"./claim-request\");\nexports.ClaimRequest = claim_request_1.default;\nconst Acknowledged = require(\"./acknowledged\");\nexports.Acknowledged = Acknowledged;\nconst lightning_invoice_1 = require(\"./lightning-invoice\");\nexports.LightningInvoice = lightning_invoice_1.default;\n// crypto, should be in it's own lib too..\nvar random_1 = require(\"./util/random\");\nexports.random = random_1.default;\nvar sha256_1 = require(\"./util/bcrypto/sha256\");\nexports.SHA256 = sha256_1.default;\nvar sha512_1 = require(\"./util/bcrypto/sha512\");\nexports.SHA512 = sha512_1.default;\nvar ripemd160_1 = require(\"./util/bcrypto/ripemd160\");\nexports.RIPEMD160 = ripemd160_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst public_key_1 = require(\"./public-key\");\nconst hash_1 = require(\"./hash\");\nconst buffutils = require(\"./util/buffutils\");\nclass LightningInvoice {\n    constructor(claimant, paymentRequest) {\n        this.claimant = claimant;\n        this.paymentRequest = paymentRequest;\n    }\n    hash() {\n        return hash_1.default.fromMessage('LightningInvoice', this.claimant.buffer, buffutils.fromString(this.paymentRequest));\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimant: this.claimant.toPOD(),\n            paymentRequest: this.paymentRequest,\n        };\n    }\n    get fee() {\n        return 0;\n    }\n    get amount() {\n        return 0;\n    }\n    get claimableAmount() {\n        return 0;\n    }\n    get kind() {\n        return 'LightningInvoice';\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'object') {\n            return new Error('LightningInvoice.fromPOD expected an object');\n        }\n        // should we use bolt11 to validate the payment request?\n        const claimant = public_key_1.default.fromPOD(data.claimant);\n        if (claimant instanceof Error) {\n            return new Error('lightninginvoice needs a publickey claimant');\n        }\n        const paymentRequest = data.paymentRequest;\n        if (typeof paymentRequest !== 'string' || !paymentRequest.startsWith('ln')) {\n            return new Error('expected valid payment request for lightninginvoice');\n        }\n        return new LightningInvoice(claimant, paymentRequest);\n    }\n}\nexports.default = LightningInvoice;\n//# sourceMappingURL=lightning-invoice.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Buffutils = require(\"./util/buffutils\");\nconst hash_1 = require(\"./hash\");\nconst bolt11 = require(\"./bolt11\");\nconst abstract_transfer_1 = require(\"./abstract-transfer\");\nclass LightningPayment extends abstract_transfer_1.default {\n    constructor(transferData, paymentRequest) {\n        super(transferData);\n        this.paymentRequest = paymentRequest;\n        let pro = bolt11.decodeBolt11(paymentRequest);\n        if (pro instanceof Error) {\n            throw 'invalid bolt11 invoice: ' + pro.message;\n        }\n        if (pro.satoshis && pro.satoshis !== transferData.amount) {\n            throw 'amount does not match invoice amount';\n        }\n    }\n    static fromPOD(data) {\n        const transferData = abstract_transfer_1.parseTransferData(data);\n        if (transferData instanceof Error) {\n            return transferData;\n        }\n        try {\n            return new LightningPayment(transferData, data.paymentRequest);\n        }\n        catch (err) {\n            return new Error(err);\n        }\n    }\n    get kind() {\n        return 'LightningPayment';\n    }\n    toPOD() {\n        return {\n            ...super.toPOD(),\n            paymentRequest: this.paymentRequest,\n        };\n    }\n    static hashOf(transferDataHash, paymentRequest) {\n        return hash_1.default.fromMessage('LightningPayment', transferDataHash.buffer, Buffutils.fromString(paymentRequest));\n    }\n    hash() {\n        return LightningPayment.hashOf(abstract_transfer_1.default.transferHash(this), this.paymentRequest);\n    }\n}\nexports.default = LightningPayment;\n//# sourceMappingURL=lightning-payment.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Magnitude {\n    constructor(n) {\n        if (n < 0 || n > 30 || !Number.isInteger(n)) {\n            throw new Error('assertion: magnitude must be between 0 and 30');\n        }\n        this.n = n;\n    }\n    static fromPOD(d) {\n        if (!Number.isSafeInteger(d) || d < 0 || d > 30) {\n            return new Error('magnitude expected an integer between 0 and 0');\n        }\n        return new Magnitude(d);\n    }\n    toAmount() {\n        return 2 ** this.n;\n    }\n    get buffer() {\n        return Uint8Array.of(this.n);\n    }\n    toPOD() {\n        return this.n;\n    }\n}\nexports.default = Magnitude;\nMagnitude.MaxMagnitude = 30;\n//# sourceMappingURL=magnitude.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isAmount(x) {\n    return typeof x === 'number' && Number.isSafeInteger(x) && x >= 0;\n}\nexports.isAmount = isAmount;\nexports.MaxMagnitude = 30;\n//# sourceMappingURL=pod.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ecc = require(\"./util/ecc\");\nconst hash_1 = require(\"./hash\");\nconst public_key_1 = require(\"./public-key\");\nconst bech32 = require(\"./util/bech32\");\nconst wif = require(\"./util/wif\");\nconst random_1 = require(\"./util/random\");\nconst Buffutils = require(\"./util/buffutils\");\nconst mu_sig_1 = require(\"./util/ecc/mu-sig\");\nconst serializedPrefix = 'privmp'; // private key moneypot\nclass PrivateKey {\n    constructor(scalar) {\n        this.scalar = scalar;\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'string') {\n            return new Error('PrivateKey.fromPOD expected a string');\n        }\n        const { prefix, words } = bech32.decode(data);\n        if (prefix !== serializedPrefix) {\n            return new Error('Got prefix: ' + prefix + ' but expected ' + serializedPrefix);\n        }\n        return PrivateKey.fromBytes(bech32.fromWords(words));\n    }\n    static fromBytes(bytes) {\n        const s = ecc.Scalar.fromBytes(bytes);\n        if (s instanceof Error) {\n            return s;\n        }\n        return new PrivateKey(s);\n    }\n    static fromRand() {\n        const buff = random_1.default(32);\n        const s = ecc.Scalar.fromBytes(buff);\n        if (s instanceof Error) {\n            throw s; // should never really happen..\n        }\n        return new PrivateKey(s);\n    }\n    static combine(privkeys) {\n        return new PrivateKey(mu_sig_1.privkeyCombine(privkeys.map(p => p.scalar)));\n    }\n    get buffer() {\n        return ecc.Scalar.toBytes(this.scalar);\n    }\n    toPOD() {\n        return bech32.encode(serializedPrefix, bech32.toWords(this.buffer));\n    }\n    toPublicKey() {\n        const point = ecc.Point.fromPrivKey(this.scalar);\n        return new public_key_1.default(point.x, point.y);\n    }\n    tweak(n) {\n        const newD = ecc.scalarAdd(this.scalar, n.scalar);\n        return new PrivateKey(newD);\n    }\n    // Just for bitcoin compatibilty, shouldn't really be used...\n    toWif(testnet = true) {\n        const prefix = testnet ? 0xef : 0x80;\n        return wif.encode(prefix, this.buffer, true);\n    }\n    derive(n) {\n        let nBuff;\n        if (n instanceof Uint8Array) {\n            nBuff = n;\n        }\n        else if (typeof n === 'bigint') {\n            nBuff = Buffutils.fromBigInt(n);\n        }\n        else if (typeof n === 'number') {\n            nBuff = Buffutils.fromVarInt(n);\n        }\n        else {\n            throw new Error('unexpected type for deriving with. must be a Uint8Array | number | bigint');\n        }\n        const tweakBy = hash_1.default.fromMessage('derive', this.toPublicKey().buffer, nBuff).buffer;\n        const tweakByN = ecc.Scalar.fromBytes(tweakBy);\n        if (tweakByN instanceof Error) {\n            throw tweakByN;\n        }\n        const newD = ecc.scalarAdd(this.scalar, tweakByN);\n        return new PrivateKey(newD);\n    }\n}\nexports.default = PrivateKey;\n//# sourceMappingURL=private-key.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hash_1 = require(\"./hash\");\nconst ecc = require(\"./util/ecc/elliptic\");\nconst bech32 = require(\"./util/bech32\");\nconst ripemd160_1 = require(\"./util/bcrypto/ripemd160\");\nconst sha256_1 = require(\"./util/bcrypto/sha256\");\nconst buffutils = require(\"./util/buffutils\");\nconst _1 = require(\".\");\nconst mu_sig_1 = require(\"./util/ecc/mu-sig\");\nconst base58_1 = require(\"./util/base58\");\nconst serializedPrefix = 'pubmp'; // public key moneypot\nclass PublicKey {\n    // dont directly use...\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'string') {\n            return new Error('PublicKey.fromPOD expected a string');\n        }\n        const { prefix, words } = bech32.decode(data);\n        if (prefix !== serializedPrefix) {\n            return new Error('Got prefix: ' + prefix + ' but expected ' + serializedPrefix);\n        }\n        return PublicKey.fromBytes(bech32.fromWords(words));\n    }\n    static fromBytes(serialized) {\n        const point = ecc.Point.fromBytes(serialized);\n        if (point instanceof Error) {\n            return point;\n        }\n        return new PublicKey(point.x, point.y);\n    }\n    static combine(pubkeys) {\n        const t = mu_sig_1.pubkeyCombine(pubkeys);\n        return new PublicKey(t.x, t.y);\n    }\n    get buffer() {\n        return ecc.Point.toBytes(this);\n    }\n    toPOD() {\n        return bech32.encode(serializedPrefix, bech32.toWords(this.buffer));\n    }\n    tweak(n) {\n        const newQ = ecc.pointAdd(this, n);\n        return new PublicKey(newQ.x, newQ.y);\n    }\n    derive(n) {\n        let nBuff;\n        if (n instanceof Uint8Array) {\n            nBuff = n;\n        }\n        else if (typeof n === 'bigint') {\n            nBuff = _1.Buffutils.fromBigInt(n);\n        }\n        else if (typeof n === 'number') {\n            nBuff = _1.Buffutils.fromVarInt(n);\n        }\n        else {\n            throw new Error('unexpected type for deriving with. must be a Uint8Array | number | bigint');\n        }\n        const tweakBy = hash_1.default.fromMessage('derive', this.buffer, nBuff).buffer;\n        const tweakByN = ecc.Scalar.fromBytes(tweakBy);\n        if (tweakByN instanceof Error) {\n            throw tweakByN;\n        }\n        const tweakPoint = ecc.Point.fromPrivKey(tweakByN);\n        const newQ = ecc.pointAdd(this, tweakPoint);\n        return new PublicKey(newQ.x, newQ.y);\n    }\n    hash() {\n        return hash_1.default.fromMessage('PublicKey', this.buffer);\n    }\n    toBitcoinAddress(testnet = true) {\n        const prefix = testnet ? 'tb' : 'bc';\n        const pubkeyHash = rmd160sha256(this.buffer);\n        const words = bech32.toWords(pubkeyHash);\n        const version = new Uint8Array(1); // [0]\n        return bech32.encode(prefix, buffutils.concat(version, words));\n    }\n    toNestedBitcoinAddress(testnet = true) {\n        const prefix = testnet ? 0xc4 : 0x05;\n        const pubkeyHash = rmd160sha256(this.buffer);\n        // redeem script\n        const redeem = rmd160sha256(buffutils.concat(new Uint8Array([0x00, 0x14]), pubkeyHash));\n        // const rmdsha =  rmd160sha256(redeem)\n        const addbytes = buffutils.concat(new Uint8Array([prefix]), redeem);\n        const sha2 = sha256_1.default.digest(sha256_1.default.digest(addbytes)).slice(0, 4);\n        // const checksum = sha2.slice(0, 4)\n        const binary = buffutils.concat(addbytes, sha2);\n        return base58_1.encode(binary);\n    }\n    toLegacyBitcoinAddress(testnet = false) {\n        const prefix = testnet ? 0x6f : 0x00;\n        const hash = rmd160sha256(this.buffer);\n        const concatVersion = buffutils.concat(new Uint8Array([prefix]), hash);\n        const sha = sha256_1.default.digest(sha256_1.default.digest(concatVersion)).slice(0, 4);\n        const enc = buffutils.concat(concatVersion, sha);\n        return base58_1.encode(enc);\n    }\n}\nexports.default = PublicKey;\nfunction rmd160sha256(data) {\n    return ripemd160_1.default.digest(sha256_1.default.digest(data));\n}\n//# sourceMappingURL=public-key.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"./util/assert\");\nconst bech32 = require(\"./util/bech32\");\nconst Buffutils = require(\"./util/buffutils\");\nconst ecc = require(\"./util/ecc\");\nconst serializedPrefix = 'sigmp'; // signature moneypot\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    // actually creates a schnorr sig. This takes a message, not a hash to prevent existential forgeries\n    static compute(message, privkey) {\n        const sig = ecc.sign(message, privkey.scalar);\n        return new Signature(sig.r, sig.s);\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'string') {\n            return new Error('Signature.fromPOD expected string');\n        }\n        const { prefix, words } = bech32.decode(data);\n        if (prefix !== serializedPrefix) {\n            return new Error('Got prefix: ' + prefix + ' but expected ' + serializedPrefix);\n        }\n        return Signature.fromBytes(bech32.fromWords(words));\n    }\n    static fromBytes(bytes) {\n        assert.equal(bytes.length, 64);\n        const r = ecc.Scalar.fromBytes(bytes.slice(0, 32));\n        if (r instanceof Error) {\n            return r;\n        }\n        const s = ecc.Scalar.fromBytes(bytes.slice(32, 64));\n        if (s instanceof Error) {\n            return s;\n        }\n        return new Signature(r, s);\n    }\n    get buffer() {\n        return Buffutils.concat(ecc.Scalar.toBytes(this.r), ecc.Scalar.toBytes(this.s));\n    }\n    verify(message, pubkey) {\n        return ecc.verify(pubkey, message, this);\n    }\n    verifyECDSA(message, pubkey) {\n        return ecc.verifyECDSA(pubkey, message, this);\n    }\n    toPOD() {\n        return bech32.encode(serializedPrefix, bech32.toWords(this.buffer));\n    }\n}\nexports.default = Signature;\n//# sourceMappingURL=signature.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AbstractStatus {\n    constructor(claimableHash) {\n        this.claimableHash = claimableHash;\n    }\n    get buffer() {\n        return this.claimableHash.buffer;\n    }\n}\nexports.default = AbstractStatus;\n//# sourceMappingURL=abstract-status.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abstract_status_1 = require(\"./abstract-status\");\nconst hash_1 = require(\"../hash\");\nconst buffutils = require(\"../util/buffutils\");\nclass BitcoinTransactionSent extends abstract_status_1.default {\n    constructor(claimableHash, txid) {\n        super(claimableHash);\n        this.txid = txid;\n    }\n    hash() {\n        return hash_1.default.fromMessage('BitcoinTransactionSent', this.buffer, this.txid);\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimableHash: this.claimableHash.toPOD(),\n            txid: buffutils.toHex(this.txid),\n        };\n    }\n    static fromPOD(obj) {\n        if (typeof obj !== 'object') {\n            return new Error('BitcoinTransactionSent.fromPOD expected an object');\n        }\n        const claimableHash = hash_1.default.fromPOD(obj.claimableHash);\n        if (claimableHash instanceof Error) {\n            return claimableHash;\n        }\n        const txid = buffutils.fromHex(obj.txid, 32);\n        if (txid instanceof Error) {\n            return txid;\n        }\n        return new BitcoinTransactionSent(claimableHash, txid);\n    }\n}\nexports.default = BitcoinTransactionSent;\n//# sourceMappingURL=bitcoin-transaction-sent.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abstract_status_1 = require(\"./abstract-status\");\nconst blinded_signature_1 = require(\"../blinded-signature\");\nconst claim_request_1 = require(\"../claim-request\");\nconst hash_1 = require(\"../hash\");\n// The response embeds the request, to make it easier to store/verify\nclass Claimed extends abstract_status_1.default {\n    constructor(claimRequest, blindedReceipts) {\n        super(claimRequest.claimableHash);\n        this.claimRequest = claimRequest;\n        this.blindedReceipts = blindedReceipts;\n    }\n    hash() {\n        const h = hash_1.default.newBuilder('ClaimResponse');\n        h.update(this.claimRequest.hash().buffer);\n        for (const blindedReceipt of this.blindedReceipts) {\n            h.update(blindedReceipt.buffer);\n        }\n        return h.digest();\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimableHash: this.claimRequest.claimableHash.toPOD(),\n            claimRequest: this.claimRequest.toPOD(),\n            blindedReceipts: this.blindedReceipts.map(x => x.toPOD()),\n        };\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'object') {\n            throw new Error('ClaimResponse must be an object');\n        }\n        const claimRequest = claim_request_1.default.fromPOD(data.claimRequest);\n        if (claimRequest instanceof Error) {\n            return claimRequest;\n        }\n        if (data.claimableHash != claimRequest.claimableHash.toPOD()) {\n            return new Error('claimRequest claimableHash doesnt claimed statuses');\n        }\n        if (!Array.isArray(data.blindedReceipts)) {\n            return new Error('expected blindedReceipts in ClaimResponse to be an array');\n        }\n        const blindedReceipts = [];\n        for (const bep of data.blindedReceipts) {\n            const blindedReceipt = blinded_signature_1.default.fromPOD(bep);\n            if (blindedReceipt instanceof Error) {\n                return blindedReceipt;\n            }\n            blindedReceipts.push(blindedReceipt);\n        }\n        return new Claimed(claimRequest, blindedReceipts);\n    }\n}\nexports.default = Claimed;\n//# sourceMappingURL=claimed.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst failed_1 = require(\"./failed\");\nconst claimed_1 = require(\"./claimed\");\nconst lightning_payment_sent_1 = require(\"./lightning-payment-sent\");\nconst bitcoin_transaction_sent_1 = require(\"./bitcoin-transaction-sent\");\nconst invoice_settled_1 = require(\"./invoice-settled\");\nconst hookin_accepted_1 = require(\"./hookin-accepted\");\nconst hookin_1 = require(\"../hookin\");\nconst lightning_payment_1 = require(\"../lightning-payment\");\nfunction computeClaimableRemaining(c, statuses) {\n    let remaining = c.claimableAmount;\n    for (const s of statuses) {\n        if (s instanceof failed_1.default) {\n            remaining += s.rebate;\n        }\n        else if (s instanceof claimed_1.default) {\n            remaining -= s.claimRequest.amount();\n        }\n        else if (s instanceof lightning_payment_sent_1.default) {\n            if (!(c instanceof lightning_payment_1.default)) {\n                throw new Error('got lighting payment sent status for a non lightning payment?');\n            }\n            const overpaid = c.fee - s.totalFees;\n            if (overpaid < 0) {\n                throw new Error('assertion failed, actual lightning fees higher than paid: ' + c.hash().toPOD());\n            }\n            remaining += overpaid;\n        }\n        else if (s instanceof invoice_settled_1.default) {\n            remaining += s.amount;\n        }\n        else if (s instanceof bitcoin_transaction_sent_1.default) {\n            // do nothing\n        }\n        else if (s instanceof hookin_accepted_1.default) {\n            if (!(c instanceof hookin_1.default)) {\n                throw new Error('assertion failure. hookin accepted for non-hookin?!');\n            }\n            remaining += Math.max(c.amount - s.consolidationFee, 0);\n        }\n        else {\n            const _ = s;\n            throw new Error('Unexpected Status: ' + s);\n        }\n    }\n    if (remaining < 0) {\n        throw new Error('assertion failed, claimable remaining is less than 0: ' + c.hash().toPOD());\n    }\n    return remaining;\n}\nexports.default = computeClaimableRemaining;\n//# sourceMappingURL=compute-claimable-remaining.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abstract_status_1 = require(\"./abstract-status\");\nconst hash_1 = require(\"../hash\");\nconst buffutils = require(\"../util/buffutils\");\nconst POD = require(\"../pod\");\nclass Failed extends abstract_status_1.default {\n    constructor(claimableHash, reason, rebate) {\n        super(claimableHash);\n        this.reason = reason;\n        this.rebate = rebate;\n    }\n    hash() {\n        return hash_1.default.fromMessage('Failed', this.buffer, buffutils.fromString(this.reason), buffutils.fromUint64(this.rebate));\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimableHash: this.claimableHash.toPOD(),\n            reason: this.reason,\n            rebate: this.rebate,\n        };\n    }\n    static fromPOD(obj) {\n        if (typeof obj !== 'object') {\n            return new Error('Failed.fromPOD expected an object');\n        }\n        const claimableHash = hash_1.default.fromPOD(obj.claimableHash);\n        if (claimableHash instanceof Error) {\n            return claimableHash;\n        }\n        const reason = obj.reason;\n        if (typeof reason !== 'string') {\n            return new Error('Failed.fromPOD expected a string reason');\n        }\n        const rebate = obj.rebate;\n        if (!POD.isAmount(rebate)) {\n            return new Error('rebate is not an amount');\n        }\n        return new Failed(claimableHash, reason, rebate);\n    }\n}\nexports.default = Failed;\n//# sourceMappingURL=failed.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abstract_status_1 = require(\"./abstract-status\");\nconst hash_1 = require(\"../hash\");\nconst POD = require(\"../pod\");\nconst buffutils = require(\"../util/buffutils\");\nclass HookinAccepted extends abstract_status_1.default {\n    constructor(claimableHash, consolidationFee) {\n        super(claimableHash);\n        this.consolidationFee = consolidationFee;\n    }\n    hash() {\n        const h = hash_1.default.newBuilder('HookinAccepted');\n        h.update(this.claimableHash.buffer);\n        h.update(buffutils.fromUint64(this.consolidationFee));\n        return h.digest();\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimableHash: this.claimableHash.toPOD(),\n            consolidationFee: this.consolidationFee,\n        };\n    }\n    static fromPOD(data) {\n        if (typeof data !== 'object') {\n            throw new Error('HookinAccepted.fromPOD must take an object');\n        }\n        const claimableHash = hash_1.default.fromPOD(data.claimableHash);\n        if (claimableHash instanceof Error) {\n            return claimableHash;\n        }\n        const consolidationFee = data.consolidationFee;\n        if (!POD.isAmount(consolidationFee)) {\n            throw new Error('HookinAccepted.fromPOD expected an amount consolidation fee');\n        }\n        return new HookinAccepted(claimableHash, consolidationFee);\n    }\n}\nexports.default = HookinAccepted;\n//# sourceMappingURL=hookin-accepted.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst claimed_1 = require(\"./claimed\");\nconst failed_1 = require(\"./failed\");\nconst bitcoin_transaction_sent_1 = require(\"./bitcoin-transaction-sent\");\nconst invoice_settled_1 = require(\"./invoice-settled\");\nconst lightning_payment_sent_1 = require(\"./lightning-payment-sent\");\nconst hookin_accepted_1 = require(\"./hookin-accepted\");\nfunction statusFromPOD(obj) {\n    if (typeof obj !== 'object' || typeof obj.kind !== 'string') {\n        return new Error('parseTransfer expected an object with a kind to parse');\n    }\n    const parser = findParser(obj.kind);\n    if (parser instanceof Error) {\n        return parser;\n    }\n    const parseResult = parser(obj);\n    if (parseResult instanceof Error) {\n        return parseResult;\n    }\n    if (parseResult.hash().toPOD() !== obj.hash) {\n        return new Error('status had mismatching hash');\n    }\n    return parseResult;\n}\nexports.statusFromPOD = statusFromPOD;\nfunction findParser(kind) {\n    switch (kind) {\n        case 'Failed':\n            return failed_1.default.fromPOD;\n        case 'BitcoinTransactionSent':\n            return bitcoin_transaction_sent_1.default.fromPOD;\n        case 'InvoiceSettled':\n            return invoice_settled_1.default.fromPOD;\n        case 'Claimed':\n            return claimed_1.default.fromPOD;\n        case 'LightningPaymentSent':\n            return lightning_payment_sent_1.default.fromPOD;\n        case 'HookinAccepted':\n            return hookin_accepted_1.default.fromPOD;\n        default:\n            return new Error('Unknown status kind: ' + kind);\n    }\n}\nfunction statusToPOD(s) {\n    if (s instanceof bitcoin_transaction_sent_1.default) {\n        return { kind: 'BitcoinTransactionSent', ...s.toPOD() };\n    }\n    else if (s instanceof failed_1.default) {\n        return { kind: 'Failed', ...s.toPOD() };\n    }\n    else if (s instanceof invoice_settled_1.default) {\n        return { kind: 'InvoiceSettled', ...s.toPOD() };\n    }\n    else if (s instanceof claimed_1.default) {\n        return { kind: 'Claimed', ...s.toPOD() };\n    }\n    else if (s instanceof lightning_payment_sent_1.default) {\n        return { kind: 'LightningPaymentSent', ...s.toPOD() };\n    }\n    else if (s instanceof hookin_accepted_1.default) {\n        return { kind: 'HookinAccepted', ...s.toPOD() };\n    }\n    else {\n        const _ = s;\n        throw new Error('uknown status: ' + s);\n    }\n}\nexports.statusToPOD = statusToPOD;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abstract_status_1 = require(\"./abstract-status\");\nconst hash_1 = require(\"../hash\");\nconst buffutils = require(\"../util/buffutils\");\nconst POD = require(\"../pod\");\nclass InvoiceSettled extends abstract_status_1.default {\n    constructor(claimableHash, amount, rPreimage, time) {\n        super(claimableHash);\n        this.amount = amount;\n        this.rPreimage = rPreimage;\n        this.time = time;\n    }\n    hash() {\n        return hash_1.default.fromMessage('InvoiceSettled', this.buffer, buffutils.fromUint64(this.amount), this.rPreimage, buffutils.fromUint64(this.time.getTime()));\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimableHash: this.claimableHash.toPOD(),\n            amount: this.amount,\n            rPreimage: buffutils.toHex(this.rPreimage),\n            time: this.time.toISOString(),\n        };\n    }\n    static fromPOD(obj) {\n        if (typeof obj !== 'object') {\n            return new Error('InvoiceSettled.fromPOD expected an object');\n        }\n        const claimableHash = hash_1.default.fromPOD(obj.claimableHash);\n        if (claimableHash instanceof Error) {\n            return claimableHash;\n        }\n        const amount = obj.amount;\n        if (!POD.isAmount(amount)) {\n            return new Error('InvoiceSettled.fromPOD expected a valid amount');\n        }\n        const rPreimage = buffutils.fromHex(obj.rPreimage, 32);\n        if (rPreimage instanceof Error) {\n            return rPreimage;\n        }\n        const ms = Date.parse(obj.time);\n        if (!Number.isFinite(ms)) {\n            return new Error('InvoiceSettled.fromPOD expected a valid time');\n        }\n        const time = new Date(ms);\n        if (time.toISOString() !== obj.time) {\n            // canonical check...\n            return new Error('InvoiceSettled.fromPOD got a strangely formatted time');\n        }\n        return new InvoiceSettled(claimableHash, amount, rPreimage, time);\n    }\n}\nexports.default = InvoiceSettled;\n//# sourceMappingURL=invoice-settled.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abstract_status_1 = require(\"./abstract-status\");\nconst hash_1 = require(\"../hash\");\nconst buffutils = require(\"../util/buffutils\");\nconst POD = require(\"../pod\");\nclass LightningPaymentSent extends abstract_status_1.default {\n    constructor(claimableHash, paymentPreimage, totalFees) {\n        super(claimableHash);\n        this.paymentPreimage = paymentPreimage;\n        this.totalFees = totalFees;\n    }\n    hash() {\n        return hash_1.default.fromMessage('LightningPaymentSent', this.buffer, this.paymentPreimage, buffutils.fromUint64(this.totalFees));\n    }\n    toPOD() {\n        return {\n            hash: this.hash().toPOD(),\n            claimableHash: this.claimableHash.toPOD(),\n            paymentPreimage: buffutils.toHex(this.paymentPreimage),\n            totalFees: this.totalFees,\n        };\n    }\n    static fromPOD(obj) {\n        if (typeof obj !== 'object') {\n            return new Error('LightningPaymentSent.fromPOD expected an object');\n        }\n        const claimableHash = hash_1.default.fromPOD(obj.claimableHash);\n        if (claimableHash instanceof Error) {\n            return claimableHash;\n        }\n        const paymentPreimage = buffutils.fromHex(obj.paymentPreimage, 32);\n        if (paymentPreimage instanceof Error) {\n            return paymentPreimage;\n        }\n        const totalFees = obj.totalFees;\n        if (!POD.isAmount(totalFees)) {\n            return new Error('LightningPaymentSent.fromPOD expected a valid totalFees');\n        }\n        return new LightningPaymentSent(claimableHash, paymentPreimage, totalFees);\n    }\n}\nexports.default = LightningPaymentSent;\n//# sourceMappingURL=lightning-payment-sent.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction default_1(x) {\n    if (!x) {\n        throw new Error('assertion failed');\n    }\n}\nexports.default = default_1;\nfunction equal(l, r) {\n    if (l !== r) {\n        console.error('assertion failed: ', l, ' !=== ', r);\n        throw new Error('assertion failed');\n    }\n}\nexports.equal = equal;\nfunction is(l, r) {\n    if (!(l instanceof r)) {\n        console.error('assertion failed: ', l, ' is not instance of ', r);\n        throw new Error('assertion failed');\n    }\n}\nexports.is = is;\nfunction check(f, x) {\n    if (f(x) !== true) {\n        console.error('assertion failed: ', x, ' didnt pass the test');\n        throw new Error('assertion failed');\n    }\n}\nexports.check = check;\n//# sourceMappingURL=assert.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nif (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n}\nconst BASE_MAP = new Uint8Array(256);\nBASE_MAP.fill(255);\nfor (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i);\n    const xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n        throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n}\nconst BASE = ALPHABET.length;\nconst LEADER = ALPHABET.charAt(0);\nconst FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\nconst iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\nfunction encode(source) {\n    if (source.length === 0) {\n        return '';\n    }\n    // Skip & count leading zeroes.\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n        pbegin++;\n        zeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    while (pbegin !== pend) {\n        let carry = source[pbegin];\n        // Apply \"b58 = b58 * 256 + ch\".\n        let i = 0;\n        for (let it = size - 1; (carry !== 0 || i < length) && it !== -1; it--, i++) {\n            carry += (256 * b58[it]) >>> 0;\n            b58[it] = carry % BASE >>> 0;\n            carry = (carry / BASE) >>> 0;\n        }\n        if (carry !== 0) {\n            throw new Error('Non-zero carry');\n        }\n        length = i;\n        pbegin++;\n    }\n    // Skip leading zeroes in base58 result.\n    let it = size - length;\n    while (it !== size && b58[it] === 0) {\n        it++;\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes);\n    for (; it < size; ++it) {\n        str += ALPHABET.charAt(b58[it]);\n    }\n    return str;\n}\nexports.encode = encode;\nfunction decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n        throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n        return new Uint8Array(0);\n    }\n    let psz = 0;\n    // Skip leading spaces.\n    if (source[psz] === ' ') {\n        return;\n    }\n    // Skip and count leading '1's.\n    let zeroes = 0;\n    let length = 0;\n    while (source[psz] === LEADER) {\n        zeroes++;\n        psz++;\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = ((source.length - psz) * FACTOR + 1) >>> 0; // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size);\n    // Process the characters.\n    while (source[psz]) {\n        // Decode character\n        let carry = BASE_MAP[source.charCodeAt(psz)];\n        // Invalid character\n        if (carry === 255) {\n            return;\n        }\n        let i = 0;\n        for (let it = size - 1; (carry !== 0 || i < length) && it !== -1; it--, i++) {\n            carry += (BASE * b256[it]) >>> 0;\n            b256[it] = carry % 256 >>> 0;\n            carry = (carry / 256) >>> 0;\n        }\n        if (carry !== 0) {\n            throw new Error('Non-zero carry');\n        }\n        length = i;\n        psz++;\n    }\n    // Skip trailing spaces.\n    if (source[psz] === ' ') {\n        return;\n    }\n    // Skip leading zeroes in b256.\n    let it = size - length;\n    while (it !== size && b256[it] === 0) {\n        it++;\n    }\n    const vch = new Uint8Array(zeroes + (size - it));\n    //vch.fill(0x00, 0, zeroes);\n    let j = zeroes;\n    while (it !== size) {\n        vch[j++] = b256[it++];\n    }\n    return vch;\n}\nexports.decodeUnsafe = decodeUnsafe;\nfunction decode(str) {\n    const buffer = decodeUnsafe(str);\n    if (buffer) {\n        return buffer;\n    }\n    throw new Error('Non-base' + BASE + ' character');\n}\nexports.decode = decode;\n//# sourceMappingURL=base58.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"../assert\");\nclass HMAC {\n    constructor(Hash, size, x = [], y = []) {\n        this.hash = Hash;\n        this.size = size;\n        this.inner = Hash();\n        this.outer = Hash();\n    }\n    init(key) {\n        // Shorten key\n        if (key.length > this.size) {\n            const h = this.hash();\n            h.init();\n            h.update(key);\n            key = h.final();\n            assert_1.default(key.length <= this.size);\n        }\n        // Pad key\n        const pad = new Uint8Array(this.size);\n        for (let i = 0; i < key.length; i++)\n            pad[i] = key[i] ^ 0x36;\n        for (let i = key.length; i < pad.length; i++)\n            pad[i] = 0x36;\n        this.inner.init();\n        this.inner.update(pad);\n        for (let i = 0; i < key.length; i++)\n            pad[i] = key[i] ^ 0x5c;\n        for (let i = key.length; i < pad.length; i++)\n            pad[i] = 0x5c;\n        this.outer.init();\n        this.outer.update(pad);\n        return this;\n    }\n    update(data) {\n        this.inner.update(data);\n        return this;\n    }\n    final() {\n        this.outer.update(this.inner.final());\n        return this.outer.final();\n    }\n}\nexports.default = HMAC;\n//# sourceMappingURL=hmac.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"../assert\");\nconst buffutils = require(\"../buffutils\");\nconst hmac_1 = require(\"./hmac\");\nconst FINALIZED = -1;\nconst DESC = new Uint8Array(8);\nconst PADDING = new Uint8Array(64);\nPADDING[0] = 0x80;\nconst r = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    7,\n    4,\n    13,\n    1,\n    10,\n    6,\n    15,\n    3,\n    12,\n    0,\n    9,\n    5,\n    2,\n    14,\n    11,\n    8,\n    3,\n    10,\n    14,\n    4,\n    9,\n    15,\n    8,\n    1,\n    2,\n    7,\n    0,\n    6,\n    13,\n    11,\n    5,\n    12,\n    1,\n    9,\n    11,\n    10,\n    0,\n    8,\n    12,\n    4,\n    13,\n    3,\n    7,\n    15,\n    14,\n    5,\n    6,\n    2,\n    4,\n    0,\n    5,\n    9,\n    7,\n    12,\n    2,\n    10,\n    14,\n    1,\n    3,\n    8,\n    11,\n    6,\n    15,\n    13,\n];\nconst rh = [\n    5,\n    14,\n    7,\n    0,\n    9,\n    2,\n    11,\n    4,\n    13,\n    6,\n    15,\n    8,\n    1,\n    10,\n    3,\n    12,\n    6,\n    11,\n    3,\n    7,\n    0,\n    13,\n    5,\n    10,\n    14,\n    15,\n    8,\n    12,\n    4,\n    9,\n    1,\n    2,\n    15,\n    5,\n    1,\n    3,\n    7,\n    14,\n    6,\n    9,\n    11,\n    8,\n    12,\n    2,\n    10,\n    0,\n    4,\n    13,\n    8,\n    6,\n    4,\n    1,\n    3,\n    11,\n    15,\n    0,\n    5,\n    12,\n    2,\n    13,\n    9,\n    7,\n    10,\n    14,\n    12,\n    15,\n    10,\n    4,\n    1,\n    5,\n    8,\n    7,\n    6,\n    2,\n    13,\n    14,\n    0,\n    3,\n    9,\n    11,\n];\nconst s = [\n    11,\n    14,\n    15,\n    12,\n    5,\n    8,\n    7,\n    9,\n    11,\n    13,\n    14,\n    15,\n    6,\n    7,\n    9,\n    8,\n    7,\n    6,\n    8,\n    13,\n    11,\n    9,\n    7,\n    15,\n    7,\n    12,\n    15,\n    9,\n    11,\n    7,\n    13,\n    12,\n    11,\n    13,\n    6,\n    7,\n    14,\n    9,\n    13,\n    15,\n    14,\n    8,\n    13,\n    6,\n    5,\n    12,\n    7,\n    5,\n    11,\n    12,\n    14,\n    15,\n    14,\n    15,\n    9,\n    8,\n    9,\n    14,\n    5,\n    6,\n    8,\n    6,\n    5,\n    12,\n    9,\n    15,\n    5,\n    11,\n    6,\n    8,\n    13,\n    12,\n    5,\n    12,\n    13,\n    14,\n    11,\n    8,\n    5,\n    6,\n];\nconst sh = [\n    8,\n    9,\n    9,\n    11,\n    13,\n    15,\n    15,\n    5,\n    7,\n    7,\n    8,\n    11,\n    14,\n    14,\n    12,\n    6,\n    9,\n    13,\n    15,\n    7,\n    12,\n    8,\n    9,\n    11,\n    7,\n    7,\n    12,\n    7,\n    6,\n    15,\n    13,\n    11,\n    9,\n    7,\n    15,\n    11,\n    8,\n    6,\n    6,\n    14,\n    12,\n    13,\n    5,\n    14,\n    13,\n    13,\n    7,\n    5,\n    15,\n    5,\n    8,\n    11,\n    14,\n    14,\n    6,\n    14,\n    6,\n    9,\n    12,\n    9,\n    12,\n    5,\n    15,\n    8,\n    8,\n    5,\n    12,\n    9,\n    12,\n    5,\n    14,\n    6,\n    8,\n    13,\n    6,\n    5,\n    15,\n    13,\n    11,\n    11,\n];\nclass RIPEMD160 {\n    constructor() {\n        this.state = new Uint32Array(5);\n        this.msg = new Uint32Array(16);\n        this.block = Buffer.allocUnsafe(64);\n        this.size = FINALIZED;\n        this.init();\n    }\n    init() {\n        this.state[0] = 0x67452301;\n        this.state[1] = 0xefcdab89;\n        this.state[2] = 0x98badcfe;\n        this.state[3] = 0x10325476;\n        this.state[4] = 0xc3d2e1f0;\n        this.size = 0;\n        return this;\n    }\n    update(data) {\n        this._update(data, data.length);\n        return this;\n    }\n    final() {\n        return this._final(new Uint8Array(20));\n    }\n    _update(data, len) {\n        assert_1.default(this.size !== FINALIZED);\n        let pos = this.size & 0x3f;\n        let off = 0;\n        this.size += len;\n        if (pos > 0) {\n            let want = 64 - pos;\n            if (want > len)\n                want = len;\n            buffutils.copy(data, this.block, pos, off, off + want);\n            pos += want;\n            len -= want;\n            off += want;\n            if (pos < 64)\n                return;\n            this.transform(this.block, 0);\n        }\n        while (len >= 64) {\n            this.transform(data, off);\n            off += 64;\n            len -= 64;\n        }\n        if (len > 0) {\n            buffutils.copy(data, this.block, 0, off, off + len);\n        }\n    }\n    /**\n     * Finalize RIPEMD160 context.\n     * @private\n     * @param {Buffer} out\n     * @returns {Buffer}\n     */\n    _final(out) {\n        assert_1.default(this.size !== FINALIZED);\n        const pos = this.size % 64;\n        const len = this.size * 8;\n        writeU32(DESC, len, 0);\n        writeU32(DESC, len * (1 / 0x100000000), 4);\n        this._update(PADDING, 1 + ((119 - pos) % 64));\n        this._update(DESC, 8);\n        for (let i = 0; i < 5; i++) {\n            writeU32(out, this.state[i], i * 4);\n            this.state[i] = 0;\n        }\n        for (let i = 0; i < 16; i++)\n            this.msg[i] = 0;\n        for (let i = 0; i < 64; i++)\n            this.block[i] = 0;\n        this.size = FINALIZED;\n        return out;\n    }\n    transform(chunk, pos) {\n        const W = this.msg;\n        let A = this.state[0];\n        let B = this.state[1];\n        let C = this.state[2];\n        let D = this.state[3];\n        let E = this.state[4];\n        let Ah = A;\n        let Bh = B;\n        let Ch = C;\n        let Dh = D;\n        let Eh = E;\n        for (let i = 0; i < 16; i++)\n            W[i] = readU32(chunk, pos + i * 4);\n        for (let j = 0; j < 80; j++) {\n            let a = A + f(j, B, C, D) + W[r[j]] + K(j);\n            let b = rotl32(a, s[j]);\n            let T = b + E;\n            A = E;\n            E = D;\n            D = rotl32(C, 10);\n            C = B;\n            B = T;\n            a = Ah + f(79 - j, Bh, Ch, Dh) + W[rh[j]] + Kh(j);\n            b = rotl32(a, sh[j]);\n            T = b + Eh;\n            Ah = Eh;\n            Eh = Dh;\n            Dh = rotl32(Ch, 10);\n            Ch = Bh;\n            Bh = T;\n        }\n        const T = this.state[1] + C + Dh;\n        this.state[1] = this.state[2] + D + Eh;\n        this.state[2] = this.state[3] + E + Ah;\n        this.state[3] = this.state[4] + A + Bh;\n        this.state[4] = this.state[0] + B + Ch;\n        this.state[0] = T;\n    }\n    static hash() {\n        return new RIPEMD160();\n    }\n    static hmac() {\n        return new hmac_1.default(RIPEMD160.hash, 64);\n    }\n    static digest(...data) {\n        const h = new RIPEMD160();\n        for (const d of data) {\n            h.update(d);\n        }\n        return h.final();\n    }\n    static mac(key, data) {\n        const m = RIPEMD160.hmac();\n        m.init(key);\n        m.update(data);\n        return m.final();\n    }\n}\nexports.default = RIPEMD160;\n/*\n * Helpers\n */\nfunction rotl32(w, b) {\n    return (w << b) | (w >>> (32 - b));\n}\nfunction f(j, x, y, z) {\n    if (j <= 15)\n        return x ^ y ^ z;\n    if (j <= 31)\n        return (x & y) | (~x & z);\n    if (j <= 47)\n        return (x | ~y) ^ z;\n    if (j <= 63)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\nfunction K(j) {\n    if (j <= 15)\n        return 0x00000000;\n    if (j <= 31)\n        return 0x5a827999;\n    if (j <= 47)\n        return 0x6ed9eba1;\n    if (j <= 63)\n        return 0x8f1bbcdc;\n    return 0xa953fd4e;\n}\nfunction Kh(j) {\n    if (j <= 15)\n        return 0x50a28be6;\n    if (j <= 31)\n        return 0x5c4dd124;\n    if (j <= 47)\n        return 0x6d703ef3;\n    if (j <= 63)\n        return 0x7a6d76e9;\n    return 0x00000000;\n}\nfunction writeU32(buf, value, offset) {\n    buf[offset + 3] = value >>> 24;\n    buf[offset + 2] = (value >> 16) & 0xff;\n    buf[offset + 1] = (value >> 8) & 0xff;\n    buf[offset] = value & 0xff;\n}\nfunction readU32(buf, offset) {\n    return ((buf[offset + 3] & 0xff) * 0x1000000 +\n        (((buf[offset + 2] & 0xff) << 16) | ((buf[offset + 1] & 0xff) << 8) | (buf[offset] & 0xff)));\n}\n//# sourceMappingURL=ripemd160.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"../assert\");\nconst hmac_1 = require(\"./hmac\");\nconst buffutils = require(\"../buffutils\");\n/*\n * Constants\n */\nconst FINALIZED = -1;\nconst DESC = new Uint8Array(8);\nconst PADDING = new Uint8Array(64);\nPADDING[0] = 0x80;\nconst K = new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2,\n]);\n/**\n * SHA256\n */\nclass SHA256 {\n    constructor() {\n        this.state = new Uint32Array(8);\n        this.msg = new Uint32Array(64);\n        this.block = new Uint8Array(64);\n        this.size = FINALIZED;\n        this.init();\n    }\n    init() {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.size = 0;\n        return this;\n    }\n    update(data) {\n        this._update(data, data.length);\n        return this;\n    }\n    final() {\n        return this._final(new Uint8Array(32));\n    }\n    _update(data, len) {\n        assert_1.default(this.size !== FINALIZED);\n        let pos = this.size & 0x3f;\n        let off = 0;\n        this.size += len;\n        if (pos > 0) {\n            let want = 64 - pos;\n            if (want > len)\n                want = len;\n            buffutils.copy(data, this.block, pos, off, off + want);\n            pos += want;\n            len -= want;\n            off += want;\n            if (pos < 64)\n                return;\n            this.transform(this.block, 0);\n        }\n        while (len >= 64) {\n            this.transform(data, off);\n            off += 64;\n            len -= 64;\n        }\n        if (len > 0) {\n            buffutils.copy(data, this.block, 0, off, off + len);\n        }\n    }\n    _final(out) {\n        assert_1.default(this.size !== FINALIZED);\n        const pos = this.size % 64;\n        const len = this.size * 8;\n        writeU32(DESC, len * (1 / 0x100000000), 0);\n        writeU32(DESC, len, 4);\n        this._update(PADDING, 1 + ((119 - pos) % 64));\n        this._update(DESC, 8);\n        for (let i = 0; i < 8; i++) {\n            writeU32(out, this.state[i], i * 4);\n            this.state[i] = 0;\n        }\n        for (let i = 0; i < 64; i++)\n            this.msg[i] = 0;\n        for (let i = 0; i < 64; i++)\n            this.block[i] = 0;\n        this.size = FINALIZED;\n        return out;\n    }\n    transform(chunk, pos) {\n        const W = this.msg;\n        let a = this.state[0];\n        let b = this.state[1];\n        let c = this.state[2];\n        let d = this.state[3];\n        let e = this.state[4];\n        let f = this.state[5];\n        let g = this.state[6];\n        let h = this.state[7];\n        let i = 0;\n        for (; i < 16; i++)\n            W[i] = readU32(chunk, pos + i * 4);\n        for (; i < 64; i++)\n            W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];\n        for (i = 0; i < 64; i++) {\n            let t1 = h + Sigma1(e);\n            t1 += Ch(e, f, g);\n            t1 += K[i] + W[i];\n            let t2 = Sigma0(a);\n            t2 += Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = d + t1;\n            d = c;\n            c = b;\n            b = a;\n            a = t1 + t2;\n        }\n        this.state[0] += a;\n        this.state[1] += b;\n        this.state[2] += c;\n        this.state[3] += d;\n        this.state[4] += e;\n        this.state[5] += f;\n        this.state[6] += g;\n        this.state[7] += h;\n    }\n    static hash() {\n        return new SHA256();\n    }\n    static hmac() {\n        return new hmac_1.default(SHA256.hash, 64);\n    }\n    static digest(...data) {\n        const h = new SHA256();\n        for (const d of data) {\n            h.update(d);\n        }\n        return h.final();\n    }\n    static mac(key, data) {\n        const m = SHA256.hmac();\n        m.init(key);\n        m.update(data);\n        return m.final();\n    }\n}\nexports.default = SHA256;\nfunction Sigma0(x) {\n    return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));\n}\nfunction Sigma1(x) {\n    return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));\n}\nfunction sigma0(x) {\n    return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);\n}\nfunction sigma1(x) {\n    return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);\n}\nfunction Ch(x, y, z) {\n    return z ^ (x & (y ^ z));\n}\nfunction Maj(x, y, z) {\n    return (x & y) | (z & (x | y));\n}\nfunction writeU32(buf, value, offset) {\n    buf[offset] = value >>> 24;\n    buf[offset + 1] = (value >> 16) & 0xff;\n    buf[offset + 2] = (value >> 8) & 0xff;\n    buf[offset + 3] = value & 0xff;\n}\nfunction readU32(buf, offset) {\n    return ((buf[offset] & 0xff) * 0x1000000 +\n        (((buf[offset + 1] & 0xff) << 16) | ((buf[offset + 2] & 0xff) << 8) | (buf[offset + 3] & 0xff)));\n}\n//# sourceMappingURL=sha256.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"../assert\");\nconst buffutils = require(\"../buffutils\");\nconst hmac_1 = require(\"./hmac\");\n/*\n * Constants\n */\nconst FINALIZED = -1;\nconst DESC = new Uint8Array(16);\nconst PADDING = new Uint8Array(128);\nPADDING[0] = 0x80;\nconst K = new Uint32Array([\n    0x428a2f98,\n    0xd728ae22,\n    0x71374491,\n    0x23ef65cd,\n    0xb5c0fbcf,\n    0xec4d3b2f,\n    0xe9b5dba5,\n    0x8189dbbc,\n    0x3956c25b,\n    0xf348b538,\n    0x59f111f1,\n    0xb605d019,\n    0x923f82a4,\n    0xaf194f9b,\n    0xab1c5ed5,\n    0xda6d8118,\n    0xd807aa98,\n    0xa3030242,\n    0x12835b01,\n    0x45706fbe,\n    0x243185be,\n    0x4ee4b28c,\n    0x550c7dc3,\n    0xd5ffb4e2,\n    0x72be5d74,\n    0xf27b896f,\n    0x80deb1fe,\n    0x3b1696b1,\n    0x9bdc06a7,\n    0x25c71235,\n    0xc19bf174,\n    0xcf692694,\n    0xe49b69c1,\n    0x9ef14ad2,\n    0xefbe4786,\n    0x384f25e3,\n    0x0fc19dc6,\n    0x8b8cd5b5,\n    0x240ca1cc,\n    0x77ac9c65,\n    0x2de92c6f,\n    0x592b0275,\n    0x4a7484aa,\n    0x6ea6e483,\n    0x5cb0a9dc,\n    0xbd41fbd4,\n    0x76f988da,\n    0x831153b5,\n    0x983e5152,\n    0xee66dfab,\n    0xa831c66d,\n    0x2db43210,\n    0xb00327c8,\n    0x98fb213f,\n    0xbf597fc7,\n    0xbeef0ee4,\n    0xc6e00bf3,\n    0x3da88fc2,\n    0xd5a79147,\n    0x930aa725,\n    0x06ca6351,\n    0xe003826f,\n    0x14292967,\n    0x0a0e6e70,\n    0x27b70a85,\n    0x46d22ffc,\n    0x2e1b2138,\n    0x5c26c926,\n    0x4d2c6dfc,\n    0x5ac42aed,\n    0x53380d13,\n    0x9d95b3df,\n    0x650a7354,\n    0x8baf63de,\n    0x766a0abb,\n    0x3c77b2a8,\n    0x81c2c92e,\n    0x47edaee6,\n    0x92722c85,\n    0x1482353b,\n    0xa2bfe8a1,\n    0x4cf10364,\n    0xa81a664b,\n    0xbc423001,\n    0xc24b8b70,\n    0xd0f89791,\n    0xc76c51a3,\n    0x0654be30,\n    0xd192e819,\n    0xd6ef5218,\n    0xd6990624,\n    0x5565a910,\n    0xf40e3585,\n    0x5771202a,\n    0x106aa070,\n    0x32bbd1b8,\n    0x19a4c116,\n    0xb8d2d0c8,\n    0x1e376c08,\n    0x5141ab53,\n    0x2748774c,\n    0xdf8eeb99,\n    0x34b0bcb5,\n    0xe19b48a8,\n    0x391c0cb3,\n    0xc5c95a63,\n    0x4ed8aa4a,\n    0xe3418acb,\n    0x5b9cca4f,\n    0x7763e373,\n    0x682e6ff3,\n    0xd6b2b8a3,\n    0x748f82ee,\n    0x5defb2fc,\n    0x78a5636f,\n    0x43172f60,\n    0x84c87814,\n    0xa1f0ab72,\n    0x8cc70208,\n    0x1a6439ec,\n    0x90befffa,\n    0x23631e28,\n    0xa4506ceb,\n    0xde82bde9,\n    0xbef9a3f7,\n    0xb2c67915,\n    0xc67178f2,\n    0xe372532b,\n    0xca273ece,\n    0xea26619c,\n    0xd186b8c7,\n    0x21c0c207,\n    0xeada7dd6,\n    0xcde0eb1e,\n    0xf57d4f7f,\n    0xee6ed178,\n    0x06f067aa,\n    0x72176fba,\n    0x0a637dc5,\n    0xa2c898a6,\n    0x113f9804,\n    0xbef90dae,\n    0x1b710b35,\n    0x131c471b,\n    0x28db77f5,\n    0x23047d84,\n    0x32caab7b,\n    0x40c72493,\n    0x3c9ebe0a,\n    0x15c9bebc,\n    0x431d67c4,\n    0x9c100d4c,\n    0x4cc5d4be,\n    0xcb3e42b6,\n    0x597f299c,\n    0xfc657e2a,\n    0x5fcb6fab,\n    0x3ad6faec,\n    0x6c44198c,\n    0x4a475817,\n]);\nclass SHA512 {\n    constructor() {\n        this.state = new Uint32Array(16);\n        this.msg = new Uint32Array(160);\n        this.block = new Uint8Array(128);\n        this.size = FINALIZED;\n        this.init();\n    }\n    /**\n     * Initialize SHA512 context.\n     */\n    init() {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xf3bcc908;\n        this.state[2] = 0xbb67ae85;\n        this.state[3] = 0x84caa73b;\n        this.state[4] = 0x3c6ef372;\n        this.state[5] = 0xfe94f82b;\n        this.state[6] = 0xa54ff53a;\n        this.state[7] = 0x5f1d36f1;\n        this.state[8] = 0x510e527f;\n        this.state[9] = 0xade682d1;\n        this.state[10] = 0x9b05688c;\n        this.state[11] = 0x2b3e6c1f;\n        this.state[12] = 0x1f83d9ab;\n        this.state[13] = 0xfb41bd6b;\n        this.state[14] = 0x5be0cd19;\n        this.state[15] = 0x137e2179;\n        this.size = 0;\n        return this;\n    }\n    update(data) {\n        this._update(data, data.length);\n        return this;\n    }\n    final() {\n        return this._final(new Uint8Array(64));\n    }\n    _update(data, len) {\n        assert_1.default(this.size !== FINALIZED);\n        let pos = this.size & 0x7f;\n        let off = 0;\n        this.size += len;\n        if (pos > 0) {\n            let want = 128 - pos;\n            if (want > len)\n                want = len;\n            buffutils.copy(data, this.block, pos, off, off + want);\n            pos += want;\n            len -= want;\n            off += want;\n            if (pos < 128)\n                return;\n            this.transform(this.block, 0);\n        }\n        while (len >= 128) {\n            this.transform(data, off);\n            off += 128;\n            len -= 128;\n        }\n        if (len > 0) {\n            buffutils.copy(data, this.block, 0, off, off + len);\n        }\n    }\n    _final(out) {\n        assert_1.default(this.size !== FINALIZED);\n        const pos = this.size % 128;\n        const len = this.size * 8;\n        writeU32(DESC, len * (1 / 0x100000000), 8);\n        writeU32(DESC, len, 12);\n        this._update(PADDING, 1 + ((239 - pos) % 128));\n        this._update(DESC, 16);\n        for (let i = 0; i < 16; i++) {\n            writeU32(out, this.state[i], i * 4);\n            this.state[i] = 0;\n        }\n        for (let i = 0; i < 160; i++)\n            this.msg[i] = 0;\n        for (let i = 0; i < 128; i++)\n            this.block[i] = 0;\n        this.size = FINALIZED;\n        return out;\n    }\n    prepare(chunk, pos) {\n        const W = this.msg;\n        let i = 0;\n        for (; i < 32; i++)\n            W[i] = readU32(chunk, pos + i * 4);\n        for (; i < 160; i += 2) {\n            const c0_hi = g1_512_hi(W[i - 4], W[i - 3]);\n            const c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n            const c1_hi = W[i - 14];\n            const c1_lo = W[i - 13];\n            const c2_hi = g0_512_hi(W[i - 30], W[i - 29]);\n            const c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n            const c3_hi = W[i - 32];\n            const c3_lo = W[i - 31];\n            W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n            W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n        }\n    }\n    transform(chunk, pos) {\n        const W = this.msg;\n        this.prepare(chunk, pos);\n        let ah = this.state[0];\n        let al = this.state[1];\n        let bh = this.state[2];\n        let bl = this.state[3];\n        let ch = this.state[4];\n        let cl = this.state[5];\n        let dh = this.state[6];\n        let dl = this.state[7];\n        let eh = this.state[8];\n        let el = this.state[9];\n        let fh = this.state[10];\n        let fl = this.state[11];\n        let gh = this.state[12];\n        let gl = this.state[13];\n        let hh = this.state[14];\n        let hl = this.state[15];\n        for (let i = 0; i < W.length; i += 2) {\n            let c0_hi = hh;\n            let c0_lo = hl;\n            let c1_hi = s1_512_hi(eh, el);\n            let c1_lo = s1_512_lo(eh, el);\n            const c2_hi = ch64_hi(eh, el, fh, fl, gh);\n            const c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n            const c3_hi = K[i];\n            const c3_lo = K[i + 1];\n            const c4_hi = W[i];\n            const c4_lo = W[i + 1];\n            const T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n            const T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n            c0_hi = s0_512_hi(ah, al);\n            c0_lo = s0_512_lo(ah, al);\n            c1_hi = maj64_hi(ah, al, bh, bl, ch);\n            c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n            const T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n            const T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n            hh = gh;\n            hl = gl;\n            gh = fh;\n            gl = fl;\n            fh = eh;\n            fl = el;\n            eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n            el = sum64_lo(dl, dl, T1_hi, T1_lo);\n            dh = ch;\n            dl = cl;\n            ch = bh;\n            cl = bl;\n            bh = ah;\n            bl = al;\n            ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n            al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n        }\n        sum64(this.state, 0, ah, al);\n        sum64(this.state, 2, bh, bl);\n        sum64(this.state, 4, ch, cl);\n        sum64(this.state, 6, dh, dl);\n        sum64(this.state, 8, eh, el);\n        sum64(this.state, 10, fh, fl);\n        sum64(this.state, 12, gh, gl);\n        sum64(this.state, 14, hh, hl);\n    }\n    static hash() {\n        return new SHA512();\n    }\n    static hmac() {\n        return new hmac_1.default(SHA512.hash, 128);\n    }\n    static digest(...data) {\n        const h = new SHA512();\n        for (const d of data) {\n            h.update(d);\n        }\n        return h.final();\n    }\n    static mac(key, data) {\n        const m = SHA512.hmac();\n        m.init(key);\n        m.update(data);\n        return m.final();\n    }\n}\nexports.default = SHA512;\n/*\n * Helpers\n */\nfunction sum64(buf, pos, ah, al) {\n    const bh = buf[pos];\n    const bl = buf[pos + 1];\n    const lo = (al + bl) >>> 0;\n    const hi = (lo < al ? 1 : 0) + ah + bh;\n    buf[pos] = hi >>> 0;\n    buf[pos + 1] = lo;\n}\nfunction sum64_hi(ah, al, bh, bl) {\n    const lo = (al + bl) >>> 0;\n    const hi = (lo < al ? 1 : 0) + ah + bh;\n    return hi >>> 0;\n}\nfunction sum64_lo(ah, al, bh, bl) {\n    const lo = al + bl;\n    return lo >>> 0;\n}\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n    let carry = 0;\n    let lo = al;\n    lo = (lo + bl) >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = (lo + cl) >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = (lo + dl) >>> 0;\n    carry += lo < dl ? 1 : 0;\n    const hi = ah + bh + ch + dh + carry;\n    return hi >>> 0;\n}\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n    const lo = al + bl + cl + dl;\n    return lo >>> 0;\n}\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    let carry = 0;\n    let lo = al;\n    lo = (lo + bl) >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = (lo + cl) >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = (lo + dl) >>> 0;\n    carry += lo < dl ? 1 : 0;\n    lo = (lo + el) >>> 0;\n    carry += lo < el ? 1 : 0;\n    const hi = ah + bh + ch + dh + eh + carry;\n    return hi >>> 0;\n}\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    const lo = al + bl + cl + dl + el;\n    return lo >>> 0;\n}\nfunction rotr64_hi(ah, al, num) {\n    const r = (al << (32 - num)) | (ah >>> num);\n    return r >>> 0;\n}\nfunction rotr64_lo(ah, al, num) {\n    const r = (ah << (32 - num)) | (al >>> num);\n    return r >>> 0;\n}\nfunction shr64_hi(ah, al, num) {\n    return ah >>> num;\n}\nfunction shr64_lo(ah, al, num) {\n    const r = (ah << (32 - num)) | (al >>> num);\n    return r >>> 0;\n}\nfunction ch64_hi(xh, xl, yh, yl, zh) {\n    let r = (xh & yh) ^ (~xh & zh);\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n    let r = (xl & yl) ^ (~xl & zl);\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction maj64_hi(xh, xl, yh, yl, zh) {\n    let r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n    let r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction s0_512_hi(xh, xl) {\n    const c0_hi = rotr64_hi(xh, xl, 28);\n    const c1_hi = rotr64_hi(xl, xh, 2); // 34\n    const c2_hi = rotr64_hi(xl, xh, 7); // 39\n    let r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction s0_512_lo(xh, xl) {\n    const c0_lo = rotr64_lo(xh, xl, 28);\n    const c1_lo = rotr64_lo(xl, xh, 2); // 34\n    const c2_lo = rotr64_lo(xl, xh, 7); // 39\n    let r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction s1_512_hi(xh, xl) {\n    const c0_hi = rotr64_hi(xh, xl, 14);\n    const c1_hi = rotr64_hi(xh, xl, 18);\n    const c2_hi = rotr64_hi(xl, xh, 9); // 41\n    let r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction s1_512_lo(xh, xl) {\n    const c0_lo = rotr64_lo(xh, xl, 14);\n    const c1_lo = rotr64_lo(xh, xl, 18);\n    const c2_lo = rotr64_lo(xl, xh, 9); // 41\n    let r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction g0_512_hi(xh, xl) {\n    const c0_hi = rotr64_hi(xh, xl, 1);\n    const c1_hi = rotr64_hi(xh, xl, 8);\n    const c2_hi = shr64_hi(xh, xl, 7);\n    let r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction g0_512_lo(xh, xl) {\n    const c0_lo = rotr64_lo(xh, xl, 1);\n    const c1_lo = rotr64_lo(xh, xl, 8);\n    const c2_lo = shr64_lo(xh, xl, 7);\n    let r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction g1_512_hi(xh, xl) {\n    const c0_hi = rotr64_hi(xh, xl, 19);\n    const c1_hi = rotr64_hi(xl, xh, 29); // 61\n    const c2_hi = shr64_hi(xh, xl, 6);\n    let r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction g1_512_lo(xh, xl) {\n    const c0_lo = rotr64_lo(xh, xl, 19);\n    const c1_lo = rotr64_lo(xl, xh, 29); // 61\n    const c2_lo = shr64_lo(xh, xl, 6);\n    let r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n        r += 0x100000000;\n    return r;\n}\nfunction writeU32(buf, value, offset) {\n    buf[offset] = value >>> 24;\n    buf[offset + 1] = (value >> 16) & 0xff;\n    buf[offset + 2] = (value >> 8) & 0xff;\n    buf[offset + 3] = value & 0xff;\n}\nfunction readU32(buf, offset) {\n    return ((buf[offset] & 0xff) * 0x1000000 +\n        (((buf[offset + 1] & 0xff) << 16) | ((buf[offset + 2] & 0xff) << 8) | (buf[offset + 3] & 0xff)));\n}\n//# sourceMappingURL=sha512.js.map","\"use strict\";\n// taken from npm package bech32\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"./assert\");\nexports.ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n// pre-compute lookup table\nconst ALPHABET_MAP = new Map();\nfor (let z = 0; z < exports.ALPHABET.length; z++) {\n    const x = exports.ALPHABET.charAt(z);\n    if (ALPHABET_MAP.get(x) !== undefined) {\n        throw new TypeError(x + ' is ambiguous');\n    }\n    ALPHABET_MAP.set(x, z);\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nexports.polymodStep = polymodStep;\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) {\n            throw new Error('Invalid prefix (' + prefix + ')');\n        }\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nexports.prefixChk = prefixChk;\nfunction encode(prefix, words) {\n    prefix = prefix.toLowerCase();\n    // determine chk mod\n    let chk = prefixChk(prefix);\n    let result = prefix + '1';\n    for (let i = 0; i < words.length; ++i) {\n        const x = words[i];\n        if (x >> 5 !== 0) {\n            throw new Error('Non 5-bit word');\n        }\n        chk = polymodStep(chk) ^ x;\n        result += exports.ALPHABET.charAt(x);\n    }\n    for (let i = 0; i < 6; ++i) {\n        chk = polymodStep(chk);\n    }\n    chk ^= 1;\n    for (let i = 0; i < 6; ++i) {\n        const v = (chk >> ((5 - i) * 5)) & 0x1f;\n        result += exports.ALPHABET.charAt(v);\n    }\n    return result;\n}\nexports.encode = encode;\nfunction decode(str) {\n    if (str.length < 8) {\n        throw new TypeError(str + ' too short');\n    }\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    const uppered = str.toUpperCase();\n    if (str !== lowered && str !== uppered) {\n        throw new Error('Mixed-case string ' + str);\n    }\n    str = lowered;\n    const split = str.lastIndexOf('1');\n    if (split === -1) {\n        throw new Error('No separator character for ' + str);\n    }\n    if (split === 0) {\n        throw new Error('Missing prefix for ' + str);\n    }\n    const prefix = str.slice(0, split);\n    const wordChars = str.slice(split + 1);\n    if (wordChars.length < 6) {\n        throw new Error('Data too short');\n    }\n    let chk = prefixChk(prefix);\n    const words = [];\n    for (let i = 0; i < wordChars.length; ++i) {\n        const c = wordChars.charAt(i);\n        const v = ALPHABET_MAP.get(c);\n        if (v === undefined) {\n            throw new Error('Unknown character ' + c);\n        }\n        chk = polymodStep(chk) ^ v;\n        // not in the checksum?\n        if (i + 6 >= wordChars.length) {\n            continue;\n        }\n        words.push(v);\n    }\n    if (chk !== 1) {\n        throw new Error('Invalid checksum for ' + str);\n    }\n    return { prefix, words };\n}\nexports.decode = decode;\nfunction convert(data, inBits, outBits, pad) {\n    // data must be array-like\n    const totalBits = data.length * inBits;\n    let totalBytes = totalBits / outBits;\n    totalBytes = pad ? Math.ceil(totalBytes) : Math.floor(totalBytes);\n    const buff = new Uint8Array(totalBytes);\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    let buffIndex = 0;\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            buff[buffIndex++] = (value >> bits) & maxV;\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            buff[buffIndex++] = (value << (outBits - bits)) & maxV;\n        }\n    }\n    else {\n        if (bits >= inBits) {\n            throw new Error('Excess padding');\n        }\n        if ((value << (outBits - bits)) & maxV) {\n            throw new Error('Non-zero padding');\n        }\n    }\n    assert.equal(buffIndex, buff.length);\n    return buff;\n}\nexports.convert = convert;\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nexports.toWords = toWords;\nfunction fromWords(words) {\n    return convert(words, 5, 8, false);\n}\nexports.fromWords = fromWords;\n//# sourceMappingURL=bech32.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffutils = require(\"./buffutils\");\nconst bech32 = require(\"./bech32\");\nconst bs58check = require(\"./bs58check\");\nfunction toBase58Check(hash, version) {\n    const payload = new Uint8Array(21);\n    payload[0] = version;\n    buffutils.copy(hash, payload, 1);\n    return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n    const words = buffutils.concat(buffutils.fromUint8(version), bech32.toWords(data));\n    return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction decodeBitcoinAddress(address) {\n    if (address.startsWith('bc1') || address.startsWith('tb1')) {\n        let decoded;\n        try {\n            decoded = bech32.decode(address);\n        }\n        catch (err) {\n            return new Error('invalid bech32 encoding for address');\n        }\n        let network;\n        if (decoded.prefix === 'bc') {\n            network = 'mainnet';\n        }\n        else if (decoded.prefix == 'tb') {\n            network = 'testnet';\n        }\n        else {\n            return new Error('unknown bech32 prefix');\n        }\n        const witnessVersion = decoded.words[0];\n        if (witnessVersion !== 0) {\n            return new Error('unknown witness version');\n        }\n        const data = bech32.fromWords(decoded.words.slice(1));\n        if (data.length === 20) {\n            return { kind: 'p2wpkh', network };\n        }\n        else if (data.length === 32) {\n            return { kind: 'p2wsh', network };\n        }\n        else {\n            return new Error('invalid length for bech32 address');\n        }\n    }\n    // must be a bas58 address\n    let decoded;\n    try {\n        decoded = bs58check.decode(address);\n    }\n    catch (err) {\n        return new Error('invalid base58 address');\n    }\n    if (decoded.length !== 21) {\n        return new Error('base58 address of unexpected length');\n    }\n    switch (decoded[0]) {\n        case 0x0:\n            return { kind: 'p2pkh', network: 'mainnet' };\n        case 0x6f:\n            return {\n                kind: 'p2pkh',\n                network: 'testnet',\n            };\n        case 0x05:\n            return {\n                kind: 'p2sh',\n                network: 'mainnet',\n            };\n        case 0xc4:\n            return {\n                kind: 'p2sh',\n                network: 'testnet',\n            };\n        default:\n            return new Error('unknown base58 address prefix');\n    }\n}\nexports.decodeBitcoinAddress = decodeBitcoinAddress;\n//# sourceMappingURL=bitcoin-address.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sha256_1 = require(\"./bcrypto/sha256\");\nconst base58 = require(\"./base58\");\nconst buffutils = require(\"./buffutils\");\nfunction checksumFn(buffer) {\n    return sha256_1.default.digest(sha256_1.default.digest(buffer));\n}\nfunction encode(payload) {\n    const checksum = checksumFn(payload).slice(0, 4);\n    return base58.encode(buffutils.concat(payload, checksum));\n}\nexports.encode = encode;\nfunction decodeRaw(buffer) {\n    const payload = buffer.slice(0, -4);\n    const checksum = buffer.slice(-4);\n    const newChecksum = checksumFn(payload);\n    if ((checksum[0] ^ newChecksum[0]) |\n        (checksum[1] ^ newChecksum[1]) |\n        (checksum[2] ^ newChecksum[2]) |\n        (checksum[3] ^ newChecksum[3])) {\n        return;\n    }\n    return payload;\n}\n// Decode a base58-check encoded string to a buffer, no result if checksum is wrong\nfunction decodeUnsafe(str) {\n    const buffer = base58.decodeUnsafe(str);\n    if (!buffer) {\n        return;\n    }\n    return decodeRaw(buffer);\n}\nexports.decodeUnsafe = decodeUnsafe;\nfunction decode(str) {\n    const buffer = base58.decode(str);\n    const payload = decodeRaw(buffer);\n    if (!payload) {\n        throw new Error('Invalid checksum');\n    }\n    return payload;\n}\nexports.decode = decode;\n//# sourceMappingURL=bs58check.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"./assert\");\nconst types = require(\"./types\");\nfunction toHex(buff) {\n    let result = '';\n    for (let i = 0; i < buff.length; i++) {\n        const value = buff[i].toString(16);\n        result += value.length === 1 ? '0' + value : value;\n    }\n    return result;\n}\nexports.toHex = toHex;\nfunction fromHex(hexString, expectedLength = 0) {\n    if (typeof hexString !== 'string') {\n        return new Error('hexString must actually be hex');\n    }\n    // TODO: check for invalid chars\n    const buff = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n    if (expectedLength > 0 && buff.length !== expectedLength) {\n        return new Error('unexpected length in hex string');\n    }\n    return buff;\n}\nexports.fromHex = fromHex;\n// returns amount of bytes copied. Does not support partial copies (i.e. target must be big enough)\nfunction copy(buff, target, targetStart = 0, sourceStart = 0, sourceEnd = buff.length) {\n    assert.is(buff, Uint8Array);\n    assert.is(target, Uint8Array);\n    // TODO: this can be optimized with .set\n    for (let i = 0; i < sourceEnd - sourceStart; i++) {\n        target[i + targetStart] = buff[i + sourceStart];\n    }\n    return sourceEnd - sourceStart;\n}\nexports.copy = copy;\nfunction slice(buff, begin = 0, end = buff.length) {\n    assert.is(buff, Uint8Array);\n    if (begin < 0) {\n        begin = Math.max(buff.length + begin, 0);\n    }\n    return new Uint8Array(buff.buffer, buff.byteOffset + begin, end - begin);\n}\nexports.slice = slice;\nfunction concat(...buffs) {\n    let totalSize = 0;\n    for (let i = 0; i < buffs.length; i++) {\n        assert.is(buffs[i], Uint8Array);\n        totalSize += buffs[i].length;\n    }\n    const res = new Uint8Array(totalSize);\n    let writeAt = 0;\n    for (let i = 0; i < buffs.length; i++) {\n        res.set(buffs[i], writeAt);\n        writeAt += buffs[i].length;\n    }\n    return res;\n}\nexports.concat = concat;\nfunction fromUint32(x) {\n    assert.check(types.isUint32, x);\n    const buff = new ArrayBuffer(4);\n    const view = new DataView(buff);\n    view.setUint32(0, x);\n    return new Uint8Array(buff);\n}\nexports.fromUint32 = fromUint32;\nfunction fromUint64(x) {\n    assert.check(types.isUint64, x);\n    const buff = new ArrayBuffer(8);\n    const view = new DataView(buff);\n    const big = ~~(x / 0x0100000000);\n    const low = x % 0x0100000000;\n    view.setUint32(0, big);\n    view.setUint32(4, low);\n    return new Uint8Array(buff);\n}\nexports.fromUint64 = fromUint64;\nfunction fromUint8(x) {\n    assert.check(types.isUint8, x);\n    const buff = new Uint8Array(1);\n    buff[0] = x;\n    return buff;\n}\nexports.fromUint8 = fromUint8;\nfunction fromVarInt(n) {\n    return fromBigInt(BigInt(n));\n}\nexports.fromVarInt = fromVarInt;\nfunction fromBigInt(n) {\n    const out = [];\n    const base = BigInt(256);\n    while (n >= base) {\n        out.push(Number(n % base));\n        n = n / base;\n    }\n    out.push(Number(n));\n    const buf = new Uint8Array(out.length);\n    buf.set(out.reverse());\n    return buf;\n}\nexports.fromBigInt = fromBigInt;\nfunction toBigInt(bytes) {\n    let result = BigInt(0);\n    const n = bytes.length;\n    // Read input in 8 byte slices\n    if (n >= 8) {\n        const view = new DataView(bytes.buffer, bytes.byteOffset);\n        for (let i = 0, k = n & ~7; i < k; i += 8) {\n            const x = view.getBigUint64(i, false);\n            result = (result << BigInt(64)) + x;\n        }\n    }\n    // Mop up any remaining bytes\n    for (let i = n & ~7; i < n; i++) {\n        result = result * BigInt(256) + BigInt(bytes[i]);\n    }\n    return result;\n}\nexports.toBigInt = toBigInt;\nfunction fromString(x) {\n    assert.check(types.isString, x);\n    return new TextEncoder().encode(x);\n}\nexports.fromString = fromString;\nfunction toString(x) {\n    return new TextDecoder().decode(x);\n}\nexports.toString = toString;\nfunction isAllZero(buff) {\n    for (let i = 0; i < buff.length; i++) {\n        if (buff[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isAllZero = isAllZero;\nfunction compare(a, b) {\n    assert.is(a, Uint8Array);\n    assert.is(b, Uint8Array);\n    const m = Math.min(a.length, b.length);\n    for (let i = 0; i < m; i++) {\n        const r = a[i] - b[i];\n        if (r !== 0) {\n            return r;\n        }\n    }\n    if (a.length < b.length) {\n        return -1;\n    }\n    if (b.length < a.length) {\n        return 1;\n    }\n    return 0;\n}\nexports.compare = compare;\nfunction equal(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equal = equal;\n// only constant time if both arrays are the same length\nfunction constTimeEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let equal = true;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            equal = false; // don't abort early, hopefully the optimizer won't realize it can LOL\n        }\n    }\n    return equal;\n}\nexports.constTimeEqual = constTimeEqual;\n//# sourceMappingURL=buffutils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"./assert\");\nconst magnitude_1 = require(\"../magnitude\");\nfunction amountToMagnitudes(amount) {\n    assert.check(Number.isInteger, amount);\n    assert.check(x => x >= 0, amount);\n    const maxCoinAmount = 2 ** magnitude_1.default.MaxMagnitude;\n    let maxCoins = 0; // how many maxCoins we need\n    if (amount > maxCoinAmount) {\n        const biggerBy = amount - maxCoinAmount;\n        maxCoins = Math.floor(biggerBy / maxCoinAmount);\n        amount -= maxCoins * maxCoinAmount;\n    }\n    const coins = [];\n    for (let shift = 0; amount > 0; shift++) {\n        if (amount % 2 === 1) {\n            coins.push(new magnitude_1.default(shift));\n        }\n        amount >>= 1; // This works because MaxMagnitude is less than 32\n    }\n    while (maxCoins-- > 0) {\n        coins.push(new magnitude_1.default(magnitude_1.default.MaxMagnitude));\n    }\n    return coins;\n}\nexports.amountToMagnitudes = amountToMagnitudes;\n//# sourceMappingURL=coins.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"./elliptic\");\nconst sha256_1 = require(\"../bcrypto/sha256\");\nconst util_1 = require(\"./util\");\nfunction blindMessage(secret, nonce, signer, message) {\n    const R = nonce;\n    const P = signer;\n    const alpha = util_1.bufferToBigInt(sha256_1.default.mac(util_1.utf8ToBuffer('alpha'), util_1.concatBuffers(secret, util_1.pointToBuffer(nonce), util_1.pointToBuffer(signer), message)));\n    // spin beta until we find quadratic residue\n    let retry = 0;\n    let beta;\n    let RPrime;\n    while (true) {\n        beta = util_1.bufferToBigInt(sha256_1.default.mac(util_1.utf8ToBuffer('beta'), util_1.concatBuffers(secret, util_1.pointToBuffer(nonce), util_1.pointToBuffer(signer), message, Uint8Array.of(retry))));\n        RPrime = elliptic_1.pointAdd(R, elliptic_1.pointMultiply(util_1.curve.g, alpha), elliptic_1.pointMultiply(P, beta));\n        if (util_1.jacobi(RPrime.y) === BigInt(1)) {\n            break;\n        }\n        else {\n            retry++;\n        }\n    }\n    // the challenge\n    const cPrime = util_1.getE(RPrime.x, P, message);\n    // the blinded challenge\n    const c = elliptic_1.scalarAdd(cPrime, beta);\n    return [{ alpha, r: RPrime.x }, { c }];\n}\nexports.blindMessage = blindMessage;\nfunction blindSign(signer, nonce, { c }) {\n    const x = signer;\n    const k = nonce;\n    const s = elliptic_1.scalarAdd(k, elliptic_1.scalarMultiply(c, x));\n    return { s };\n}\nexports.blindSign = blindSign;\nfunction unblind({ alpha, r }, blindedSig) {\n    const s = elliptic_1.scalarAdd(blindedSig.s, alpha);\n    return { r, s };\n}\nexports.unblind = unblind;\n//# sourceMappingURL=blind.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _1 = require(\".\");\n// This module exposes functions that:\n//\n//     - Sanity-check inputs to avoid mistakes\n//     - Validate runtime types since lib may be consumed from JS instead of TS\n//     - Validate input data / business logic\n//\n// This module throws CheckError so that check-site can avoid swallowing\n// extraneous exceptions.\nclass CheckError extends Error {\n    constructor(...args) {\n        super(...args);\n        Error.captureStackTrace(this, CheckError);\n    }\n}\nexports.CheckError = CheckError;\n// like assert() except it throws CheckError.\n//\n// Use this instead of manually throwing.\nfunction check(assertion, message) {\n    if (!assertion) {\n        throw new CheckError(message);\n    }\n}\nexports.check = check;\nfunction privkeysAreUnique(privkeys) {\n    // validate runtime type\n    check(Array.isArray(privkeys), 'privkeys must be array');\n    // validate data\n    check(privkeys.length > 0, 'privkeys array was empty');\n    const seen = new Set();\n    for (const privkey of privkeys) {\n        check(isValidPrivkey(privkey), 'privkey must be valid');\n        const serialized = _1.Scalar.toHex(privkey);\n        check(!seen.has(serialized), 'privkeys must be unique');\n        seen.add(serialized);\n    }\n    return privkeys;\n}\nexports.privkeysAreUnique = privkeysAreUnique;\nfunction isValidPrivkey(privkey) {\n    return typeof privkey === 'bigint' && privkey >= BigInt(1) && privkey < _1.util.curve.n;\n}\nexports.isValidPrivkey = isValidPrivkey;\n// export function checkPrivkey(privkey: Scalar): Scalar {\n//     // validate runtime type\n//     check(typeof privkey === 'bigint', 'privkey must be bigint')\n//     // validate data\n//     check(privkey >= BigInt(1) , 'privkey must be in range 1 to n-1')\n//     check(privkey < util.curve.n, 'privkey must be in range 1 to n-1')\n//     return privkey\n// }\nfunction isValidSignature(sig) {\n    return (typeof sig === 'object' &&\n        typeof sig.r === 'bigint' &&\n        typeof sig.s === 'bigint' &&\n        sig.r > BigInt(0) &&\n        sig.r < _1.util.curve.p &&\n        sig.s > BigInt(0) &&\n        sig.s < _1.util.curve.n);\n}\nexports.isValidSignature = isValidSignature;\nfunction isValidPubkey(point) {\n    if (typeof point !== 'object') {\n        return false;\n    }\n    const { x, y } = point;\n    if (typeof x !== 'bigint') {\n        return false;\n    }\n    if (typeof y !== 'bigint') {\n        return false;\n    }\n    return (y * y - (x * x * x + _1.util.curve.a * x + _1.util.curve.b)) % _1.util.curve.p == BigInt(0);\n}\nexports.isValidPubkey = isValidPubkey;\n//# sourceMappingURL=check.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst check = require(\"./check\");\nconst util_1 = require(\"./util\");\nexports.Scalar = {\n    fromBytes(buf) {\n        const priv = util_1.bufferToBigInt(buf);\n        if (!check.isValidPrivkey(priv)) {\n            return new Error('scalar was not valid private key');\n        }\n        return priv;\n    },\n    fromHex(hex) {\n        const buff = util_1.bufferFromHex(hex);\n        if (buff instanceof Error) {\n            return buff;\n        }\n        const priv = util_1.bufferToBigInt(buff);\n        if (!check.isValidPrivkey(priv)) {\n            return new Error('scalar was not valid private key');\n        }\n        return priv;\n    },\n    toBytes(n) {\n        return util_1.buffer32FromBigInt(n);\n    },\n    toHex(n) {\n        return util_1.bufferToHex(util_1.buffer32FromBigInt(n));\n    },\n};\nexports.Point = {\n    fromPrivKey(privkey) {\n        if (!check.isValidPrivkey(privkey)) {\n            throw new Error('scalar was not valid private key');\n        }\n        return pointMultiply(util_1.curve.g, privkey);\n    },\n    fromBytes(buf) {\n        return util_1.pointFromBuffer(buf);\n    },\n    fromX(x, isOdd) {\n        return util_1.pointFromX(x, isOdd ? BigInt(1) : BigInt(0));\n    },\n    fromHex(hex) {\n        const buff = util_1.bufferFromHex(hex);\n        if (buff instanceof Error) {\n            throw buff;\n        }\n        return exports.Point.fromBytes(buff);\n    },\n    toHex(point) {\n        return util_1.bufferToHex(util_1.pointToBuffer(point));\n    },\n    toBytes(point) {\n        return util_1.pointToBuffer(point);\n    },\n};\nexports.INFINITE_POINT = new (class {\n    get x() {\n        throw new Error(\"infinite point doesn't have an x\");\n    }\n    get y() {\n        throw new Error(\"infinite point doesn't have a y\");\n    }\n})();\n// SCALAR MATH\nfunction scalarAdd(a, b) {\n    return (a + b) % util_1.curve.n;\n}\nexports.scalarAdd = scalarAdd;\nfunction scalarMultiply(a, b) {\n    return (a * b) % util_1.curve.n;\n}\nexports.scalarMultiply = scalarMultiply;\nfunction scalarNegate(a) {\n    return (util_1.curve.n - a) % util_1.curve.n;\n}\nexports.scalarNegate = scalarNegate;\n// scalar^-1 mod N\nfunction scalarInverse(a) {\n    return util_1.modInverse(a, util_1.curve.n);\n}\nexports.scalarInverse = scalarInverse;\n// POINT MATH\n//\n// TODO: Should point functions propagate INFINITY_POINT\n// instead of failing on x/y access so that callsite can perceive INFINITY_POINT?\nfunction pointEq(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\nexports.pointEq = pointEq;\nfunction pointAdd(...points) {\n    check.check(points.length > 1, 'can only add 1 or more points');\n    let point = points[0];\n    for (let i = 1; i < points.length; i++) {\n        point = fastAdd(point, points[i]);\n    }\n    return point;\n}\nexports.pointAdd = pointAdd;\nfunction pointSubtract(a, b) {\n    b = { x: b.x, y: (util_1.curve.p - b.y) % util_1.curve.p };\n    return pointAdd(a, b);\n}\nexports.pointSubtract = pointSubtract;\nfunction pointMultiply(point, scalar) {\n    scalar = scalar % util_1.curve.n;\n    return fastMultiply(point, scalar);\n}\nexports.pointMultiply = pointMultiply;\n// NAIVE IMPL\nfunction naiveAdd(a, b) {\n    if (a === exports.INFINITE_POINT) {\n        return b;\n    }\n    if (b === exports.INFINITE_POINT) {\n        return a;\n    }\n    if (a.x === b.x && a.y !== b.y) {\n        return exports.INFINITE_POINT;\n    }\n    const lam = a.x === b.x && a.y === b.y\n        ? ((BigInt(3) * a.x * a.x + util_1.curve.a) * util_1.powmod(BigInt(2) * a.y, util_1.curve.p - BigInt(2), util_1.curve.p)) % util_1.curve.p\n        : ((b.y - a.y) * util_1.powmod(b.x - a.x, util_1.curve.p - BigInt(2), util_1.curve.p)) % util_1.curve.p;\n    const x3 = (lam * lam - a.x - b.x) % util_1.curve.p;\n    const y = util_1.mod(lam * (a.x - x3) - a.y, util_1.curve.p);\n    return { x: x3, y };\n}\nfunction naiveMultiply(point, scalar) {\n    scalar = scalar % util_1.curve.n;\n    let r = exports.INFINITE_POINT;\n    for (let i = BigInt(0); i < BigInt(256); i++) {\n        if ((scalar >> i) & BigInt(1)) {\n            r = naiveAdd(r, point);\n        }\n        point = naiveAdd(point, point);\n    }\n    return r;\n}\nexports.naiveMultiply = naiveMultiply;\n// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\nfunction inv(a, n) {\n    if (a === BigInt(0)) {\n        return BigInt(0);\n    }\n    let [lm, hm, low, high] = [BigInt(1), BigInt(0), util_1.mod(a, n), n];\n    while (low > 1) {\n        const r = high / low;\n        const [nm, _new] = [hm - lm * r, high - low * r];\n        [lm, low, hm, high] = [nm, _new, lm, low];\n    }\n    return lm % n;\n}\nfunction fromJacobian(j) {\n    if (j[0] === BigInt(0) && j[1] === BigInt(0)) {\n        return exports.INFINITE_POINT;\n    }\n    const z = inv(j[2], util_1.curve.p);\n    const x = (j[0] * z ** BigInt(2)) % util_1.curve.p;\n    const y = util_1.mod(j[1] * z ** BigInt(3), util_1.curve.p);\n    return { x, y };\n}\nfunction toJacobian(point) {\n    return [point.x, point.y, BigInt(1)];\n}\nfunction jacobianDouble(p) {\n    if (p[1] === BigInt(0)) {\n        return [BigInt(0), BigInt(0), BigInt(0)];\n    }\n    const ysq = p[1] ** BigInt(2) % util_1.curve.p;\n    const S = (BigInt(4) * p[0] * ysq) % util_1.curve.p;\n    const M = (BigInt(3) * p[0] ** BigInt(2) + util_1.curve.a * p[2] ** BigInt(4)) % util_1.curve.p;\n    const nx = (M ** BigInt(2) - BigInt(2) * S) % util_1.curve.p;\n    const ny = (M * (S - nx) - BigInt(8) * ysq ** BigInt(2)) % util_1.curve.p;\n    const nz = (BigInt(2) * p[1] * p[2]) % util_1.curve.p;\n    return [nx, ny, nz];\n}\nfunction jacobianAdd(p, q) {\n    const P = util_1.curve.p;\n    if (p[1] === BigInt(0)) {\n        return q;\n    }\n    if (q[1] === BigInt(0)) {\n        return p;\n    }\n    const U1 = (p[0] * q[2] ** BigInt(2)) % P;\n    const U2 = (q[0] * p[2] ** BigInt(2)) % P;\n    const S1 = (p[1] * q[2] ** BigInt(3)) % P;\n    const S2 = (q[1] * p[2] ** BigInt(3)) % P;\n    if (U1 === U2) {\n        return S1 === S2 ? jacobianDouble(p) : [BigInt(0), BigInt(0), BigInt(1)];\n    }\n    const H = U2 - U1;\n    const R = S2 - S1;\n    const H2 = (H * H) % P;\n    const H3 = (H * H2) % P;\n    const U1H2 = (U1 * H2) % P;\n    const nx = (R ** BigInt(2) - H3 - BigInt(2) * U1H2) % P;\n    const ny = (R * (U1H2 - nx) - S1 * H3) % P;\n    const nz = (H * p[2] * q[2]) % P;\n    return [nx, ny, nz];\n}\nfunction jacobianMultiply(a, n) {\n    if (a[1] === BigInt(0) || n === BigInt(0)) {\n        return [BigInt(0), BigInt(0), BigInt(1)];\n    }\n    if (n === BigInt(1)) {\n        return a;\n    }\n    if (n < BigInt(0) || n >= util_1.curve.n) {\n        return jacobianMultiply(a, n % util_1.curve.n);\n    }\n    if (n % BigInt(2) === BigInt(0)) {\n        return jacobianDouble(jacobianMultiply(a, n / BigInt(2)));\n    }\n    else {\n        // n % BigInt(2)  === BigInt(1)\n        return jacobianAdd(jacobianDouble(jacobianMultiply(a, n / BigInt(2))), a);\n    }\n}\nfunction fastMultiply(point, scalar) {\n    return fromJacobian(jacobianMultiply(toJacobian(point), scalar));\n}\nfunction fastAdd(a, b) {\n    return fromJacobian(jacobianAdd(toJacobian(a), toJacobian(b)));\n}\n//# sourceMappingURL=elliptic.js.map","\"use strict\";\n// CORE DATA\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar elliptic_1 = require(\"./elliptic\");\nexports.Scalar = elliptic_1.Scalar;\nexports.Point = elliptic_1.Point;\nexports.INFINITE_POINT = elliptic_1.INFINITE_POINT;\n// CURVE MATH\nvar elliptic_2 = require(\"./elliptic\");\nexports.scalarAdd = elliptic_2.scalarAdd;\nexports.scalarMultiply = elliptic_2.scalarMultiply;\nexports.pointMultiply = elliptic_2.pointMultiply;\nexports.pointAdd = elliptic_2.pointAdd;\nvar signature_1 = require(\"./signature\");\nexports.Signature = signature_1.Signature;\nexports.sign = signature_1.sign;\nexports.verify = signature_1.verify;\nexports.verifyECDSA = signature_1.verifyECDSA;\nvar blind_1 = require(\"./blind\");\nexports.blindMessage = blind_1.blindMessage;\nexports.blindSign = blind_1.blindSign;\nexports.unblind = blind_1.unblind;\n// MULTI SIGNATURES\nconst muSig = require(\"./mu-sig\");\nexports.muSig = muSig;\n// CONVENIENCE\nconst util = require(\"./util\");\nexports.util = util;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"../assert\");\nconst _1 = require(\".\");\nconst check = require(\"./check\");\nconst sha256_1 = require(\"../bcrypto/sha256\");\nconst util_1 = require(\"./util\");\nconst elliptic_1 = require(\"./elliptic\");\n// https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/\nfunction calculateL(pubkeys) {\n    return sha256_1.default.digest(util_1.concatBuffers(...pubkeys.map(util_1.pointToBuffer)));\n}\nfunction pubkeyCombine(pubkeys) {\n    assert.equal(pubkeys.length > 0, true);\n    const L = calculateL(pubkeys);\n    let X = _1.INFINITE_POINT;\n    for (let i = 0; i < pubkeys.length; i++) {\n        const Xi = pubkeys[i];\n        const coefficient = calculateCoefficient(L, i);\n        const summand = _1.pointMultiply(Xi, coefficient);\n        if (X === _1.INFINITE_POINT) {\n            X = summand;\n        }\n        else {\n            X = _1.pointAdd(X, summand);\n        }\n    }\n    return X;\n}\nexports.pubkeyCombine = pubkeyCombine;\nfunction privkeyCombine(privkeys) {\n    assert.equal(privkeys.length > 0, true);\n    check.privkeysAreUnique(privkeys);\n    const Xs = [];\n    let R = _1.INFINITE_POINT;\n    for (const privateKey of privkeys) {\n        const Xi = _1.Point.fromPrivKey(privateKey);\n        Xs.push(Xi);\n        if (R === _1.INFINITE_POINT) {\n            R = Xi;\n        }\n        else {\n            R = _1.pointAdd(R, Xi);\n        }\n    }\n    const L = sha256_1.default.digest(util_1.concatBuffers(...Xs.map(util_1.pointToBuffer)));\n    let X = BigInt(0);\n    for (let i = 0; i < privkeys.length; i++) {\n        const Xi = privkeys[i];\n        const coefficient = calculateCoefficient(L, i);\n        const summand = elliptic_1.scalarMultiply(Xi, coefficient);\n        if (X === BigInt(0)) {\n            X = summand;\n        }\n        else {\n            X = elliptic_1.scalarAdd(X, summand);\n        }\n    }\n    return X;\n}\nexports.privkeyCombine = privkeyCombine;\nconst MUSIG_TAG = sha256_1.default.digest(util_1.utf8ToBuffer('MuSig coefficient'));\nfunction calculateCoefficient(L, idx) {\n    const ab = new ArrayBuffer(4);\n    const view = new DataView(ab);\n    view.setUint32(0, idx, true); // true for LE\n    const idxBuf = new Uint8Array(ab);\n    const data = sha256_1.default.digest(util_1.concatBuffers(MUSIG_TAG, MUSIG_TAG, L, idxBuf));\n    return util_1.bufferToBigInt(data) % util_1.curve.n;\n}\n//# sourceMappingURL=mu-sig.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst check = require(\"./check\");\nconst elliptic_1 = require(\"./elliptic\");\nconst util_1 = require(\"./util\");\nexports.Signature = {\n    fromBytes(buf) {\n        if (buf.length !== 64) {\n            return new Error('signature buf expected 64 bytes');\n        }\n        const r = util_1.bufferToBigInt(buf.slice(0, 32));\n        const s = util_1.bufferToBigInt(buf.slice(32, 64));\n        // TODO: checkSignature here or just let bad sigs fail in verify()?\n        return { r, s };\n    },\n    fromHex(hex) {\n        const buff = util_1.bufferFromHex(hex);\n        if (buff instanceof Error) {\n            return buff;\n        }\n        return exports.Signature.fromBytes(buff);\n    },\n    toBytes({ r, s }) {\n        return util_1.concatBuffers(util_1.buffer32FromBigInt(r), util_1.buffer32FromBigInt(s));\n    },\n    toHex(sig) {\n        return util_1.bufferToHex(exports.Signature.toBytes(sig));\n    },\n};\nfunction sign(message, privkey) {\n    if (!check.isValidPrivkey(privkey)) {\n        throw new Error('tried to sign with invalid privkey');\n    }\n    const m = message;\n    const d = privkey;\n    const k0 = util_1.getK0(d, m);\n    const R = elliptic_1.pointMultiply(util_1.curve.g, k0);\n    const k = util_1.getK(R, k0); // nonce\n    const e = util_1.getE(R.x, elliptic_1.Point.fromPrivKey(d), m); // challenge\n    const s = (k + e * d) % util_1.curve.n;\n    const sig = { r: R.x, s };\n    if (!check.isValidSignature(sig)) {\n        throw new Error('signing produced invalid sig?!');\n    }\n    return sig;\n}\nexports.sign = sign;\nfunction verify(pubkey, message, sig) {\n    if (!check.isValidPubkey(pubkey)) {\n        throw new Error('invalid pubkey provided');\n    }\n    if (!check.isValidSignature(sig)) {\n        throw new Error('invalid sig');\n    }\n    const m = message;\n    const P = pubkey;\n    const e = util_1.getE(sig.r, P, m);\n    const R = elliptic_1.pointSubtract(elliptic_1.pointMultiply(util_1.curve.g, sig.s), elliptic_1.pointMultiply(P, e));\n    if (R === elliptic_1.INFINITE_POINT) {\n        return false;\n    }\n    else if (util_1.jacobi(R.y) !== BigInt(1)) {\n        return false;\n    }\n    else if (R.x !== sig.r) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\nexports.verify = verify;\nfunction verifyECDSA(pubkey, message, sig) {\n    if (!check.isValidPubkey(pubkey)) {\n        throw new Error('invalid pubkey provided');\n    }\n    if (!check.isValidSignature(sig)) {\n        throw new Error('invalid sig');\n    }\n    const m = message;\n    const P = pubkey;\n    let e = elliptic_1.Scalar.fromBytes(m);\n    if (e instanceof Error) {\n        throw new Error('invalid e scalar');\n    }\n    let sInv = util_1.modInverse(sig.s, util_1.curve.n);\n    let u1 = util_1.mod(e * sInv, util_1.curve.n);\n    let u2 = util_1.mod(sig.r * sInv, util_1.curve.n);\n    let S = elliptic_1.pointAdd(elliptic_1.pointMultiply(util_1.curve.g, u1), elliptic_1.pointMultiply(P, u2));\n    if (S === elliptic_1.INFINITE_POINT) {\n        return false;\n    }\n    if (S.x === sig.r) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexports.verifyECDSA = verifyECDSA;\n// this is for ecdsa?! not schnorr ?!\nfunction ecdsaRecover(message, sig, j) {\n    // var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }\n    // var sigr = new BN(sigObj.r)\n    // var sigs = new BN(sigObj.s)\n    // if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)\n    if (!check.isValidSignature(sig)) {\n        throw new Error('invalid sig');\n    }\n    if ((3 & j) !== j) {\n        throw new Error('The recovery param is more than two bits');\n    }\n    let e = elliptic_1.Scalar.fromBytes(message);\n    if (e instanceof Error) {\n        throw e;\n    }\n    let r = sig.r;\n    // A set LSB signifies that the y-coordinate is odd\n    var isYOdd = (j & 1) == 1;\n    var isSecondKey = j >> 1;\n    // if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    //   throw new Error('Unable to find sencond key candinate');\n    if (r >= util_1.curve.p % util_1.curve.n && isSecondKey) {\n        throw new Error('Unable to find second key coordinate');\n    }\n    // 1.1. Let x = r + jn.\n    const r2 = elliptic_1.Point.fromX(r + (isSecondKey ? util_1.curve.n : BigInt(0)), isYOdd);\n    if (r2 instanceof Error) {\n        throw r2;\n    }\n    let rInv = util_1.modInverse(sig.r, util_1.curve.n);\n    //var s1 = n.sub(e).mul(rInv).umod(n);\n    let s1 = util_1.mod((util_1.curve.n - e) * rInv, util_1.curve.n);\n    // var s2 = s.mul(rInv).umod(n);\n    let s2 = util_1.mod(sig.s * rInv, util_1.curve.n);\n    // 1.6.1 Compute Q = r^-1 (sR -  eG)\n    //               Q = r^-1 (sR + -eG)\n    // return this.g.mulAdd(s1, r, s2);\n    return elliptic_1.pointAdd(elliptic_1.pointMultiply(util_1.curve.g, s1), elliptic_1.pointMultiply(r2, s2));\n}\nexports.ecdsaRecover = ecdsaRecover;\n//# sourceMappingURL=signature.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"../assert\");\nconst sha256_1 = require(\"../bcrypto/sha256\");\nconst check_1 = require(\"./check\");\n// secp256k1 parameters\nexports.curve = {\n    a: BigInt(0),\n    b: BigInt(7),\n    p: BigInt('115792089237316195423570985008687907853269984665640564039457584007908834671663'),\n    g: {\n        x: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n        y: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    },\n    // order\n    n: BigInt('115792089237316195423570985008687907852837564279074904382605163141518161494337'),\n};\n// Handles negative quotients.\n//\n//      -34 % 23 === -11\n//      mod(-34, 23) === 12\nfunction mod(a, b) {\n    return ((a % b) + b) % b;\n}\nexports.mod = mod;\n// pows then mods, but uses intermediate mods to keep intermediate number within bigint range\nfunction powmod(base, exp, m) {\n    if (exp === BigInt(0)) {\n        return BigInt(1);\n    }\n    if (exp % BigInt(2) === BigInt(0)) {\n        return mod(powmod(base, exp / BigInt(2), m) ** BigInt(2), m);\n    }\n    else {\n        return mod(base * powmod(base, exp - BigInt(1), m), m);\n    }\n}\nexports.powmod = powmod;\n// a^-1 mod m\nfunction modInverse(a, m) {\n    if (a < 0 || m <= a) {\n        a = mod(a, m);\n    }\n    let [c, d] = [a, m];\n    let q = d / c;\n    let [uc, vc, ud, vd] = [BigInt(1), BigInt(0), BigInt(0), BigInt(1)];\n    while (c !== BigInt(0)) {\n        [q, c, d] = [d / c, mod(d, c), c];\n        [uc, vc, ud, vd] = [ud - q * uc, vd - q * vc, uc, vc];\n    }\n    // At this point, d is the GCD, and ud*a+vd*m = d.\n    // If d == 1, this means that ud is a inverse.\n    assert_1.default(d === BigInt(1));\n    if (ud > 0) {\n        return ud;\n    }\n    else {\n        return ud + m;\n    }\n}\nexports.modInverse = modInverse;\nfunction bigIntSqrt(n) {\n    if (n < BigInt(0)) {\n        throw new Error('cannot sqrt negative number');\n    }\n    if (n < BigInt(2)) {\n        return n;\n    }\n    // tslint:disable-next-line: no-shadowed-variable\n    function newtonIteration(n, x0) {\n        const x1 = (n / x0 + x0) >> BigInt(1);\n        if (x0 === x1 || x0 === x1 - BigInt(1)) {\n            return x0;\n        }\n        return newtonIteration(n, x1);\n    }\n    return newtonIteration(n, BigInt(1));\n}\nfunction bufferToHex(buf) {\n    let result = '';\n    for (const b of buf) {\n        const value = b.toString(16);\n        result += value.length === 1 ? '0' + value : value;\n    }\n    return result;\n}\nexports.bufferToHex = bufferToHex;\nfunction bufferFromHex(hex) {\n    if (hex.length % 2 === 1 || !/^[0-9a-fA-F]+$/.test(hex)) {\n        return new Error('invalid hex string');\n    }\n    return new Uint8Array(hex.match(/.{1,2}/g).map(byte => Number.parseInt(byte, 16)));\n}\nexports.bufferFromHex = bufferFromHex;\n// export function bufferToBigInt(buf: Uint8Array): bigint {\n//     return BigInt('0x' + bufferToHex(buf))\n// }\nfunction bufferToBigInt(bytes) {\n    let result = BigInt(0);\n    const n = bytes.length;\n    // Read input in 8 byte slices\n    if (n >= 8) {\n        const view = new DataView(bytes.buffer, bytes.byteOffset);\n        for (let i = 0, k = n & ~7; i < k; i += 8) {\n            const x = view.getBigUint64(i, false);\n            result = (result << BigInt(64)) + x;\n        }\n    }\n    // Mop up any remaining bytes\n    for (let i = n & ~7; i < n; i++) {\n        result = result * BigInt(256) + BigInt(bytes[i]);\n    }\n    return result;\n}\nexports.bufferToBigInt = bufferToBigInt;\n// Buffer is fixed-length 32bytes\nfunction buffer32FromBigInt(n) {\n    const out = [];\n    const base = BigInt(256);\n    while (n >= base) {\n        out.push(Number(n % base));\n        n = n / base;\n    }\n    out.push(Number(n));\n    if (out.length > 32) {\n        throw new Error('bigint overflows 32 byte buffer');\n    }\n    const buf = new Uint8Array(32);\n    buf.set(out.reverse(), 32 - out.length);\n    return buf;\n}\nexports.buffer32FromBigInt = buffer32FromBigInt;\nfunction concatBuffers(...bufs) {\n    let totalSize = 0;\n    for (const buf of bufs) {\n        assert_1.default(buf instanceof Uint8Array);\n        totalSize += buf.length;\n    }\n    const res = new Uint8Array(totalSize);\n    let writeAt = 0;\n    for (const buf of bufs) {\n        res.set(buf, writeAt);\n        writeAt += buf.length;\n    }\n    return res;\n}\nexports.concatBuffers = concatBuffers;\n// 33 bytes: // first byte represents y, next 32 bytes are x coord\nfunction pointFromBuffer(buf) {\n    if (buf.length !== 33) {\n        return new Error('invalid point buffer');\n    }\n    if (![0x02, 0x03].includes(buf[0])) {\n        return new Error('not compressed');\n    }\n    // odd is BigInt(1)  or BigInt(0)\n    const odd = BigInt(buf[0] - 0x02);\n    const x = bufferToBigInt(buf.slice(1, 33));\n    return pointFromX(x, odd);\n}\nexports.pointFromBuffer = pointFromBuffer;\nfunction pointFromX(x, isOdd) {\n    if (isOdd !== BigInt(0) && isOdd !== BigInt(1)) {\n        throw new Error('isOdd must be 0n or 1n');\n    }\n    const { p } = exports.curve;\n    const ysq = (powmod(x, BigInt(3), p) + BigInt(7)) % p;\n    const y0 = powmod(ysq, (p + BigInt(1)) / BigInt(4), p);\n    if (powmod(y0, BigInt(2), p) !== ysq) {\n        return new Error('point not on curve');\n    }\n    const y = (y0 & BigInt(1)) !== isOdd ? p - y0 : y0;\n    const point = { x, y };\n    assert_1.default(check_1.isValidPubkey(point));\n    return point;\n}\nexports.pointFromX = pointFromX;\nfunction pointToBuffer(point) {\n    // 0x02: y is even\n    // 0x03: y is odd\n    const b0 = point.y % BigInt(2) === BigInt(0) ? 0x02 : 0x03;\n    const xbuf = buffer32FromBigInt(point.x);\n    assert_1.default(xbuf.length === 32);\n    const result = new Uint8Array(33);\n    result.set([b0], 0);\n    result.set(xbuf, 1);\n    return result;\n}\nexports.pointToBuffer = pointToBuffer;\nfunction constantTimeBufferEquals(a, b) {\n    const aLen = a.length;\n    const bLen = b.length;\n    const len = Math.max(aLen, bLen);\n    let result = 0;\n    for (let i = 0; i < len; i++) {\n        result |= a[i % aLen] ^ b[i % bLen];\n    }\n    result |= aLen ^ bLen;\n    return result === 0;\n}\nexports.constantTimeBufferEquals = constantTimeBufferEquals;\nfunction utf8ToBuffer(text) {\n    return new TextEncoder().encode(text);\n}\nexports.utf8ToBuffer = utf8ToBuffer;\nfunction isPointOnCurve({ x, y }) {\n    const { p, a, b } = exports.curve;\n    return (y * y - (x * x * x + a * x + b)) % p === BigInt(0);\n}\nexports.isPointOnCurve = isPointOnCurve;\nfunction jacobi(y) {\n    return powmod(y, (exports.curve.p - BigInt(1)) / BigInt(2), exports.curve.p);\n}\nexports.jacobi = jacobi;\nfunction getK(R, k0) {\n    return jacobi(R.y) === BigInt(1) ? k0 : exports.curve.n - k0;\n}\nexports.getK = getK;\nfunction getK0(privkey, message) {\n    const k0 = bufferToBigInt(sha256_1.default.digest(concatBuffers(buffer32FromBigInt(privkey), message))) % exports.curve.n;\n    if (k0 === BigInt(0)) {\n        // We got incredibly unlucky\n        throw new Error('k0 is zero');\n    }\n    return k0;\n}\nexports.getK0 = getK0;\nfunction getE(Rx, P, m) {\n    return bufferToBigInt(sha256_1.default.digest(concatBuffers(buffer32FromBigInt(Rx), pointToBuffer(P), m))) % exports.curve.n;\n}\nexports.getE = getE;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction randomBrowser(size) {\n    const buff = new Uint8Array(size);\n    window.crypto.getRandomValues(buff);\n    return buff;\n}\nexports.default = randomBrowser;\n//# sourceMappingURL=random-browser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction is(t) {\n    return (x) => x instanceof t;\n}\nexports.is = is;\nfunction isBuffer32(x) {\n    return x instanceof Uint8Array && x.length === 32;\n}\nexports.isBuffer32 = isBuffer32;\nfunction isBuffer33(x) {\n    return x instanceof Uint8Array && x.length === 33;\n}\nexports.isBuffer33 = isBuffer33;\nfunction isUint8(x) {\n    return Number.isInteger(x) && x >= 0 && x < 2 ** 8;\n}\nexports.isUint8 = isUint8;\nfunction isUint32(x) {\n    return Number.isInteger(x) && x >= 0 && x < 2 ** 32;\n}\nexports.isUint32 = isUint32;\nfunction isUint64(x) {\n    return Number.isInteger(x) && x >= 0 && x <= Number.MAX_SAFE_INTEGER;\n}\nexports.isUint64 = isUint64;\nfunction isString(x) {\n    return typeof x === 'string';\n}\nexports.isString = isString;\nfunction isArrayOf(f) {\n    return (x) => Array.isArray(x) && x.every(f);\n}\nexports.isArrayOf = isArrayOf;\nfunction isOneOf(arr) {\n    return (x) => arr.includes(x);\n}\nexports.isOneOf = isOneOf;\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bs58check = require(\"./bs58check\");\nfunction decodeRaw(buffer, version) {\n    // check version only if defined\n    if (version !== undefined && buffer[0] !== version) {\n        throw new Error('Invalid network version');\n    }\n    // uncompressed\n    if (buffer.length === 33) {\n        return {\n            version: buffer[0],\n            privateKey: buffer.slice(1, 33),\n            compressed: false,\n        };\n    }\n    // invalid length\n    if (buffer.length !== 34) {\n        throw new Error('Invalid WIF length');\n    }\n    // invalid compression flag\n    if (buffer[33] !== 0x01) {\n        throw new Error('Invalid compression flag');\n    }\n    return {\n        version: buffer[0],\n        privateKey: buffer.slice(1, 33),\n        compressed: true,\n    };\n}\nexports.decodeRaw = decodeRaw;\nfunction encodeRaw(version, privateKey, compressed = true) {\n    const result = new Uint8Array(compressed ? 34 : 33);\n    result[0] = version;\n    result.set(privateKey, 1);\n    if (compressed) {\n        result[33] = 0x01;\n    }\n    return result;\n}\nexports.encodeRaw = encodeRaw;\nfunction decode(str, version) {\n    return decodeRaw(bs58check.decode(str), version);\n}\nexports.decode = decode;\nfunction encode(version, privateKey, compressed = true) {\n    return bs58check.encode(encodeRaw(version, privateKey, compressed));\n}\nexports.encode = encode;\n//# sourceMappingURL=wif.js.map","import * as Docs from '../docs';\nimport getClaimableByInputOwner from '../requests/get-claimable-by-input-owner';\nimport Config from '../config';\n\n// unoptimized\nconst ctx: Worker = self as any;\n\nctx.addEventListener('message', (message: MessageEvent) => syncWorkers(message.data[0], message.data[1]));\n\nasync function syncWorkers(coins: Docs.Coin[], config: Config) {\n  for (const coin of coins) {\n    const claimable = await getClaimableByInputOwner(config, coin.owner);\n    if (!claimable) {\n      continue;\n    }\n    ctx.postMessage([claimable.toPOD(), coin.owner]);\n  }\n  ctx.postMessage('d');\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import * as hi from 'moneypot-lib';\nimport Config from '../config';\nimport makeRequest, { RequestError } from './make-request';\n\nexport default async function getClaimableByInputOwner(config: Config, inputOwnerStr: string) {\n  const url = `${config.custodianUrl}/claimable-by-input-owner/${inputOwnerStr}`;\n\n  const claimablePOD = await makeRequest<(hi.POD.Claimable & hi.POD.Acknowledged) | null>(url);\n\n  if (claimablePOD instanceof RequestError) {\n    throw claimablePOD;\n  }\n  if (!claimablePOD) {\n    return undefined;\n  }\n\n  const ackdClaimable = hi.Acknowledged.claimableFromPOD(claimablePOD);\n  if (ackdClaimable instanceof Error) {\n    console.error(ackdClaimable);\n    throw new Error('could not parse claimable');\n  }\n\n  const claimable = ackdClaimable.contents;\n\n  if (!(claimable instanceof hi.AbstractTransfer)) {\n    throw new Error('got a claimable by input owner, that was not actually an abstract transfer');\n  }\n\n  let found = false;\n  for (const input of claimable.inputs) {\n    if (input.owner.toPOD() === inputOwnerStr) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    throw new Error('got a claimable that didnt have correct input owner');\n  }\n  \n  if (!ackdClaimable.verify(config.custodian.acknowledgementKey)) { \n    throw new Error(\"Claimable is not properly acknowledged.\") // awkward..?\n  }\n  return ackdClaimable;\n}\n","export class RequestError {\n  public statusCode: number;\n  public message: any;\n\n  constructor(message: any, statusCode: number) {\n    this.message = message;\n    this.statusCode = statusCode;\n  }\n}\n\n// if body does a post..\nexport default async function makeRequest<T>(url: string, body?: any): Promise<T | RequestError> {\n  let fetchResult;\n\n  try {\n    fetchResult = await fetch(url, {\n      method: body === undefined ? 'GET' : 'POST',\n      body: body === undefined ? undefined : JSON.stringify(body),\n    });\n  } catch (err) {\n    return new RequestError(err, 0);\n  }\n\n  let json = await fetchResult.json();\n\n  if (fetchResult.status !== 200) {\n    console.log('giving a fetch error');\n    return new RequestError(json, fetchResult.status);\n  }\n\n  return json as T;\n}\n"],"sourceRoot":""}